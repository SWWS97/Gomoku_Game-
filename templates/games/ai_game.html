{% load static %}
<!doctype html>
<html lang="ko">
<head>
  <script>
    (function() {
      const theme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>AI 대전 - 오목조목</title>
  <style>
    :root{
      --cell: 44px;
      --margin: 30px;
      --wood: #d4b781;
      --line: #7b5c3a;
      --border: #3e2a1f;
      --bg: #faf7f2;
      --topbar-bg: #fff;
      --topbar-border: #b08f66;
      --player-bg: #fff;
      --player-border: #ccc;
      --text: #333;
      --text-secondary: #666;
      --modal-bg: #fff;
      --timer-bg: rgba(255,255,255,0.95);
      --timer-border: #d4b781;
      --toast-bg: white;
    }

    [data-theme="dark"] {
      --wood: #2a2218;
      --line: #8b6f4b;
      --border: #8b6f4b;
      --bg: #0f0f1a;
      --topbar-bg: #16213e;
      --topbar-border: #4ade80;
      --player-bg: #1e293b;
      --player-border: #374151;
      --text: #e5e7eb;
      --text-secondary: #9ca3af;
      --modal-bg: #16213e;
      --timer-bg: rgba(22, 33, 62, 0.95);
      --timer-border: #4ade80;
      --toast-bg: #1e293b;
    }

    html, body { height:100%; margin:0; background:var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, sans-serif; }

    .topbar{
      display:flex; align-items:center; gap:14px;
      padding:12px 16px 6px; font-weight:700;
      color: var(--text);
    }
    .topbar .right{ margin-left:auto; display:flex; gap:14px; align-items:center; }
    .pill{
      padding:.45rem .9rem; border:1.5px solid var(--topbar-border); border-radius:.6rem;
      background:var(--topbar-bg); cursor:pointer; color:var(--text);
      font-size:0.85rem; font-weight:700; text-decoration:none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.15s ease;
    }
    .pill:hover{ transform:translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
    .pill:active{ transform:translateY(0); }
    [data-theme="dark"] .pill{ box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    .pill.theme-toggle{ background: linear-gradient(135deg, #374151, #1f2937); color: #fff; border-color: #374151; }
    [data-theme="dark"] .pill.theme-toggle{ background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1f2937; border-color: #fbbf24; }

    .players{ display:flex; gap:16px; }
    .player-info{
      display:flex; align-items:center; gap:6px;
      padding:.4rem .7rem; border:1px solid var(--player-border);
      border-radius:.4rem; background:var(--player-bg);
      font-size:.9rem; color:var(--text);
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    .player-info .label{ color:var(--text-secondary); font-size:.8rem; }
    .player-info.current-turn{ border-color: #4a7c59; background: rgba(74, 124, 89, 0.1); }

    .difficulty-badge{
      padding: 0.25rem 0.6rem;
      border-radius: 0.4rem;
      font-size: 0.75rem;
      font-weight: 700;
    }
    .difficulty-badge.easy{ background: #d4edda; color: #155724; }
    .difficulty-badge.normal{ background: #fff3cd; color: #856404; }
    .difficulty-badge.hard{ background: #f8d7da; color: #721c24; }
    [data-theme="dark"] .difficulty-badge.easy{ background: rgba(74, 222, 128, 0.2); color: #4ade80; }
    [data-theme="dark"] .difficulty-badge.normal{ background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    [data-theme="dark"] .difficulty-badge.hard{ background: rgba(248, 113, 113, 0.2); color: #f87171; }

    /* Board */
    .board-wrap{
      position:relative;
      width: calc(14 * var(--cell) + 2 * var(--margin));
      height: calc(14 * var(--cell) + 2 * var(--margin));
      border: 6px solid var(--border);
      background:
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 35px,
          rgba(0,0,0,.03) 35px,
          rgba(0,0,0,.03) 36px
        ),
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 80px,
          rgba(0,0,0,.02) 80px,
          rgba(0,0,0,.02) 81px
        ),
        linear-gradient(160deg, #e8c882 0%, #d4b781 30%, #c9a86c 60%, #d4b781 100%);
      border-radius: 6px;
      box-shadow:
        0 18px 26px rgba(0,0,0,.25),
        inset 0 1px 0 rgba(255,255,255,.25),
        inset 0 0 20px rgba(0,0,0,.06);
      overflow: visible;
      margin: 10px auto 36px;
    }
    [data-theme="dark"] .board-wrap{
      background:
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 35px,
          rgba(255,255,255,.03) 35px,
          rgba(255,255,255,.03) 36px
        ),
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 80px,
          rgba(255,255,255,.02) 80px,
          rgba(255,255,255,.02) 81px
        ),
        linear-gradient(160deg, #342a20 0%, #2a2218 30%, #201a12 60%, #2a2218 100%);
      box-shadow:
        0 18px 26px rgba(0,0,0,.5),
        inset 0 1px 0 rgba(200,169,110,.1),
        inset 0 0 20px rgba(0,0,0,.2);
    }

    .grid{ position:absolute; inset:0; display:block; }
    .layer{ position:absolute; inset:0; pointer-events:none; }

    .stone{
      position:absolute; width:5.6%; height:5.6%; transform:translate(-50%,-50%); border-radius:50%;
      pointer-events:none; filter: drop-shadow(0 3px 4px rgba(0,0,0,.4));
    }
    .stone.B{
      background:
        radial-gradient(circle at 32% 26%, rgba(255,255,255,.12) 0%, transparent 40%),
        radial-gradient(circle at 30% 28%, #4a4a4a 0%, #262626 45%, #0f0f0f 70%),
        radial-gradient(circle at 68% 74%, rgba(255,255,255,.15), rgba(255,255,255,0) 55%);
      box-shadow: inset 1px 1px 4px rgba(255,255,255,.1), inset -7px -7px 14px rgba(0,0,0,.6);
    }
    .stone.W{
      background:
        radial-gradient(circle at 32% 26%, rgba(255,255,255,.95) 0%, transparent 35%),
        radial-gradient(circle at 30% 28%, #ffffff 0%, #f1f1f1 45%, #e2e2e2 70%),
        radial-gradient(circle at 68% 78%, rgba(0,0,0,.1), rgba(0,0,0,0) 55%);
      box-shadow: inset 1px 1px 3px rgba(255,255,255,.8), inset -7px -7px 14px rgba(0,0,0,.1);
    }
    /* 미리보기 돌 (조준점) */
    .stone.preview{
      opacity: 0.4;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.2));
    }
    .stone.preview.aimed{
      opacity: 0.65;
      filter: drop-shadow(0 3px 4px rgba(0,0,0,.4));
    }
    .stone.preview.aimed::after{
      content: '';
      position: absolute;
      top: 50%; left: 50%;
      width: 35%; height: 35%;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle, rgba(255, 107, 107, 0.9) 0%, rgba(255, 107, 107, 0) 70%);
      box-shadow: 0 0 8px rgba(255, 107, 107, 0.6);
      animation: aimPulse 1s ease-in-out infinite;
    }
    @keyframes aimPulse {
      0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.6; transform: translate(-50%, -50%) scale(0.85); }
    }
    /* 마지막 착수 표시 */
    .stone.last{
      animation: stonePulse 1.2s ease-in-out 3;
    }
    @keyframes stonePulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 3px 4px rgba(0,0,0,.4));
      }
      50% {
        transform: translate(-50%, -50%) scale(1.15);
        filter: drop-shadow(0 0 14px rgba(255, 107, 107, 0.9)) drop-shadow(0 3px 4px rgba(0,0,0,.4));
      }
    }

    .pt{
      position:absolute;
      width:var(--cell); height:var(--cell);
      transform:translate(-50%,-50%);
      pointer-events:auto;
      cursor:pointer;
      background:transparent;
      border:none;
      padding:0;
      z-index:2;
      -webkit-tap-highlight-color: transparent;
    }
    .pt:hover::after, .pt.aimed::after{
      content:'';
      position:absolute;
      top:50%; left:50%;
      width:18px; height:18px;
      border-radius:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
    }
    .pt:hover::after{ background: radial-gradient(circle at 35% 35%, rgba(0,0,0,.18), rgba(0,0,0,0) 60%); }
    .pt:active::after{
      content:'';
      position:absolute;
      top:50%; left:50%;
      width:28px; height:28px;
      border-radius:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
      background: radial-gradient(circle at 35% 35%, rgba(74, 124, 89, .5), rgba(74, 124, 89, 0) 60%);
    }
    .pt.aimed::after{
      background: var(--aim-color, rgba(0,0,0,0.5));
      box-shadow: 0 0 8px var(--aim-color, rgba(0,0,0,0.3));
    }
    .pt.forbidden{ cursor:not-allowed; }
    .pt.forbidden:hover::after{ background: rgba(255,0,0,0.3); }

    /* 착수 확인 버튼 */
    .confirm-move-btn{
      display: none;
      position: absolute;
      z-index: 200;
      padding: 8px 24px;
      font-size: 0.9rem;
      white-space: nowrap;
      width: max-content;
      font-weight: 800;
      letter-spacing: 1px;
      color: #fff;
      background: linear-gradient(135deg, #43a047, #2e7d32);
      border: none;
      border-radius: 16px;
      cursor: pointer;
      box-shadow: 0 3px 10px rgba(46, 125, 50, 0.4), inset 0 1px 0 rgba(255,255,255,0.2);
      transform: translate(-50%, 8px);
      transition: all 0.15s ease;
    }
    .confirm-move-btn:hover{
      transform: translate(-50%, 6px);
      box-shadow: 0 5px 16px rgba(46, 125, 50, 0.5), inset 0 1px 0 rgba(255,255,255,0.2);
      background: linear-gradient(135deg, #4caf50, #388e3c);
    }
    .confirm-move-btn:active{
      transform: translate(-50%, 8px) scale(0.97);
      box-shadow: 0 1px 4px rgba(46, 125, 50, 0.3);
    }
    .confirm-move-btn.visible{
      display: block;
      animation: confirmAppear 0.2s ease-out;
    }
    @keyframes confirmAppear {
      from { opacity: 0; transform: translate(-50%, 14px); }
      to { opacity: 1; transform: translate(-50%, 8px); }
    }
    [data-theme="dark"] .confirm-move-btn{
      background: linear-gradient(135deg, #4ade80, #22c55e);
      color: #0f172a;
      box-shadow: 0 3px 10px rgba(74, 222, 128, 0.35), inset 0 1px 0 rgba(255,255,255,0.15);
    }
    [data-theme="dark"] .confirm-move-btn:hover{
      background: linear-gradient(135deg, #6ee7b7, #34d399);
      box-shadow: 0 5px 16px rgba(74, 222, 128, 0.45), inset 0 1px 0 rgba(255,255,255,0.15);
    }

    /* AI 생각 중 표시 */
    .ai-thinking{
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--modal-bg);
      padding: 1.5rem 2rem;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      z-index: 100;
      display: none;
      align-items: center;
      gap: 12px;
      color: var(--text);
    }
    .ai-thinking.visible{ display: flex; }
    .ai-thinking .spinner{
      width: 24px; height: 24px;
      border: 3px solid var(--player-border);
      border-top-color: #4a7c59;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin{ 0%{ transform: rotate(0deg); } 100%{ transform: rotate(360deg); } }

    /* 게임 종료 모달 */
    .game-over-modal{
      display:none;
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.6);
      z-index:1000;
      align-items:center;
      justify-content:center;
    }
    .modal-content{
      background:var(--modal-bg);
      padding:2.5rem 3rem;
      border-radius:1rem;
      box-shadow:0 10px 40px rgba(0,0,0,0.3);
      text-align:center;
      max-width:400px;
      animation: modalFadeIn 0.3s ease;
      color: var(--text);
    }
    [data-theme="dark"] .modal-content{ border: 2px solid #374151; }
    @keyframes modalFadeIn{ from{ opacity:0; transform:translateY(-20px); } to{ opacity:1; transform:translateY(0); } }
    .modal-content h2{ margin:0 0 1rem; font-size:1.8rem; color:#7a2e2e; }
    [data-theme="dark"] .modal-content h2{ color: #4ade80; }
    .modal-content .winner-name{ font-size:2.2rem; font-weight:900; margin:1rem 0; }
    .modal-content .winner-stone{ font-size:3rem; margin:0.5rem 0; }
    .modal-content .btn-group{
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 1.5rem;
    }
    .modal-content .btn-group button{
      min-width: 120px;
      padding: 0.85rem 2rem;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      border: none;
      border-radius: 0.5rem;
      transition: all 0.2s;
      white-space: nowrap;
    }
    .modal-content .btn-group .modal-btn{
      background: linear-gradient(135deg, #7a2e2e, #5a1e1e);
      color: #fff;
    }
    .modal-content .btn-group .modal-btn:hover{
      background: linear-gradient(135deg, #5a1e1e, #4a0e0e);
    }
    .modal-content .btn-group .btn-secondary{
      background: linear-gradient(135deg, #6b7280, #4b5563);
      color: #fff;
    }
    .modal-content .btn-group .btn-secondary:hover{
      background: linear-gradient(135deg, #4b5563, #374151);
    }
    [data-theme="dark"] .modal-content .btn-group .modal-btn{
      background: linear-gradient(135deg, #dc2626, #b91c1c);
    }
    [data-theme="dark"] .modal-content .btn-group .modal-btn:hover{
      background: linear-gradient(135deg, #ef4444, #dc2626);
    }
    [data-theme="dark"] .modal-content .btn-group .btn-secondary{
      background: linear-gradient(135deg, #4b5563, #374151);
    }
    [data-theme="dark"] .modal-content .btn-group .btn-secondary:hover{
      background: linear-gradient(135deg, #6b7280, #4b5563);
    }

    /* 모바일 반응형 */
    @media (max-width: 768px) {
      .topbar{ flex-wrap: wrap; gap: 8px; padding: 8px 12px; font-size: 0.85rem; }
      .topbar .right{ width: 100%; justify-content: flex-start; gap: 8px; margin-top: 8px; }
      .pill{ padding: 0.35rem 0.7rem; font-size: 0.78rem; }
      .players{ gap: 8px; flex-wrap: wrap; }
      .player-info{ padding: 0.3rem 0.5rem; font-size: 0.75rem; }
      .board-wrap{
        width: calc(100vw - 8px);
        max-width: 540px;
        height: calc(100vw - 8px);
        max-height: 540px;
        margin: 6px auto 16px;
        border: 5px solid var(--border);
      }
      .modal-content{ padding: 1.5rem 2rem; max-width: 90%; }
      .modal-content h2{ font-size: 1.4rem; }
      .pt{ width: calc(var(--cell) * 1.5); height: calc(var(--cell) * 1.5); min-width: 44px; min-height: 44px; }
    }

    @media (max-width: 375px) {
      .board-wrap{ margin-top: 10px; }
      .modal-content{ padding: 1rem 1.5rem; }
      .pt{
        width: calc(var(--cell) * 1.2);
        height: calc(var(--cell) * 1.2);
        min-width: 36px;
        min-height: 36px;
      }
      .pt:hover::after, .pt:active::after{
        width: 14px;
        height: 14px;
      }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      .board-wrap{ width: 660px; height: 660px; }
    }

    /* 토스트 */
    .toast-container{
      position: fixed; top: 80px; right: 20px; z-index: 9999;
      display: flex; flex-direction: column; gap: 12px; max-width: 400px;
    }
    .toast{
      background: var(--toast-bg);
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      border-left: 4px solid;
      display: flex;
      align-items: center;
      gap: 12px;
      animation: slideIn 0.3s ease-out;
      min-width: 300px;
      color: var(--text);
    }
    .toast.error{ border-left-color: #c53030; }
    .toast.info{ border-left-color: #4a7c89; }
    @keyframes slideIn{ from{ transform: translateX(400px); opacity: 0; } to{ transform: translateX(0); opacity: 1; } }
  </style>
</head>
<body>
  <div class="topbar">
    <span>AI 대전</span>
    <span class="difficulty-badge {{ difficulty }}">
      {% if difficulty == 'easy' %}EASY{% elif difficulty == 'normal' %}NORMAL{% else %}HARD{% endif %}
    </span>
    <div class="players">
      <div class="player-info" id="blackInfo">
        <span class="label">흑(●)</span>
        <span id="blackName">{% if player_color == 'B' %}나{% else %}오목조목AI{% endif %}</span>
      </div>
      <div class="player-info" id="whiteInfo">
        <span class="label">백(○)</span>
        <span id="whiteName">{% if player_color == 'W' %}나{% else %}오목조목AI{% endif %}</span>
      </div>
    </div>
    <div class="right">
      <button class="pill" id="bgm-mute-btn" style="background:linear-gradient(135deg, #6b7280, #555); border-color:#444; color:#fff; font-size:13px;">BGM</button>
      <button class="pill" id="lobbyBtn">로비로가기</button>
      <button class="pill" id="restartBtn">다시하기</button>
      <button class="pill theme-toggle" id="themeToggle">다크모드</button>
    </div>
  </div>

  <div class="board-wrap" id="boardWrap">
    <svg id="grid" class="grid" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
    <div class="layer" id="stones"></div>
    <div class="layer" id="points"></div>
    <button class="confirm-move-btn" id="confirm-move-btn">착수</button>
  </div>

  <!-- AI 생각 중 표시 -->
  <div class="ai-thinking" id="aiThinking">
    <div class="spinner"></div>
    <span>AI 생각 중...</span>
  </div>

  <!-- 게임 종료 모달 -->
  <div class="game-over-modal" id="gameOverModal">
    <div class="modal-content">
      <h2 id="resultTitle">게임 종료</h2>
      <div class="winner-stone" id="winnerStone"></div>
      <div class="winner-name" id="winnerName"></div>
      <div class="btn-group">
        <button class="modal-btn" id="confirmResultBtn">확인</button>
      </div>
    </div>
  </div>

  <!-- 로비 이동 확인 모달 -->
  <div class="game-over-modal" id="restartConfirmModal" style="display:none;">
    <div class="modal-content">
      <h2>다시하기</h2>
      <p style="margin: 16px 0; color: var(--text-secondary);">게임이 진행 중입니다.<br>정말 다시 시작하시겠습니까?</p>
      <div class="btn-group">
        <button class="modal-btn" id="restartConfirmCancel" style="background: #6b7280;">취소</button>
        <button class="modal-btn" id="restartConfirmOk">다시하기</button>
      </div>
    </div>
  </div>

  <div class="game-over-modal" id="lobbyConfirmModal" style="display:none;">
    <div class="modal-content">
      <h2>게임 진행 중</h2>
      <p style="margin: 16px 0; color: var(--text-secondary);">게임이 진행 중입니다.<br>정말 로비로 이동하시겠습니까?</p>
      <div class="btn-group">
        <button class="modal-btn" id="lobbyConfirmCancel" style="background: #6b7280;">취소</button>
        <button class="modal-btn" id="lobbyConfirmOk">이동</button>
      </div>
    </div>
  </div>

  <div class="toast-container" id="toastContainer"></div>

  <script src="{% static 'js/omok-ai.js' %}"></script>
  <script>
  (function(){
    const SIZE = 15;
    const playerColor = "{{ player_color }}";
    const difficulty = "{{ difficulty }}";

    // 게임 컨트롤러 초기화
    let gameController = new AIGameController(playerColor, difficulty);

    // DOM 요소
    const boardWrap = document.getElementById("boardWrap");
    const stonesLayer = document.getElementById("stones");
    const pointsLayer = document.getElementById("points");
    const confirmBtn = document.getElementById("confirm-move-btn");
    const aiThinking = document.getElementById("aiThinking");
    const gameOverModal = document.getElementById("gameOverModal");
    const blackInfo = document.getElementById("blackInfo");
    const whiteInfo = document.getElementById("whiteInfo");

    let aimedCoords = null;
    let previewStone = null;

    // ===== 착수 소리 (Web Audio API) =====
    let audioCtx = null;

    function initAudio() {
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
          console.error('AudioContext 생성 실패:', e);
        }
      }
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    function playStoneSound() {
      try {
        if (!audioCtx) initAudio();
        if (!audioCtx || audioCtx.state !== 'running') {
          if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => actuallyPlaySound());
            return;
          }
          return;
        }
        actuallyPlaySound();
      } catch(e) {
        console.error('착수 소리 재생 실패:', e);
      }
    }

    function actuallyPlaySound() {
      try {
        if (!audioCtx || audioCtx.state !== 'running') return;

        const bufferSize = audioCtx.sampleRate * 0.05;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 1000;

        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);

        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        noise.start(audioCtx.currentTime);
        noise.stop(audioCtx.currentTime + 0.05);
      } catch(e) {
        console.error('소리 생성 실패:', e);
      }
    }

    // 사용자 상호작용 시 AudioContext 초기화
    document.addEventListener('click', initAudio, { once: true });

    // 미리보기 돌 표시
    function showPreview(x, y, aimed) {
      hidePreview();

      // 빈 칸이 아니면 표시 안 함
      if (!gameController.board.isEmpty(x, y)) return;

      const innerMin = 8, innerMax = 92;
      const step = (innerMax - innerMin) / (SIZE - 1);
      const px = innerMin + x * step;
      const py = innerMin + y * step;

      const preview = document.createElement("div");
      preview.className = "stone " + playerColor + " preview";
      if (aimed) preview.classList.add("aimed");
      preview.style.left = px + "%";
      preview.style.top = py + "%";
      preview.id = "preview-stone";
      stonesLayer.appendChild(preview);
      previewStone = preview;
    }

    function hidePreview() {
      if (previewStone) {
        previewStone.remove();
        previewStone = null;
      }
    }

    // 그리드 그리기
    function drawGrid() {
      const grid = document.getElementById("grid");
      const innerMin = 8, innerMax = 92;
      const step = (innerMax - innerMin) / (SIZE - 1);
      let html = "";

      // 배경 및 내부 테두리
      html += `<rect x="0" y="0" width="100" height="100" fill="var(--wood)"/>`;
      html += `<rect x="1.2" y="1.2" width="97.6" height="97.6" fill="none"
                   stroke="var(--border)" stroke-width="2.4" rx="2" ry="2"/>`;

      // 선 그리기
      for (let i = 0; i < SIZE; i++) {
        const pos = innerMin + i * step;
        html += `<line x1="${innerMin}" y1="${pos}" x2="${innerMax}" y2="${pos}" stroke="var(--line)" stroke-width="0.6"/>`;
        html += `<line x1="${pos}" y1="${innerMin}" x2="${pos}" y2="${innerMax}" stroke="var(--line)" stroke-width="0.6"/>`;
      }

      // 화점 (천원점) - 15x15 기준
      const starPoints = [[4,4],[4,12],[8,8],[12,4],[12,12]];
      for (const [gx, gy] of starPoints) {
        const cx = innerMin + (gx - 1) * step;
        const cy = innerMin + (gy - 1) * step;
        html += `<circle cx="${cx}" cy="${cy}" r="1.3" fill="var(--line)" opacity="0.9"/>`;
      }

      grid.innerHTML = html;
    }

    // 포인트(클릭 영역) 생성
    let touchCoords = null;
    function createPoints() {
      pointsLayer.innerHTML = "";
      const innerMin = 8, innerMax = 92;
      const step = (innerMax - innerMin) / (SIZE - 1);

      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const btn = document.createElement("button");
          btn.className = "pt";
          btn.dataset.x = x;
          btn.dataset.y = y;
          btn.style.left = `${innerMin + x * step}%`;
          btn.style.top = `${innerMin + y * step}%`;
          btn.addEventListener("click", onPointClick);

          // 미리보기 이벤트 (PC)
          btn.addEventListener("mouseenter", (e) => {
            if (gameController.gameOver || !gameController.isPlayerTurn()) return;
            const bx = +e.currentTarget.dataset.x;
            const by = +e.currentTarget.dataset.y;
            // 조준 중인 위치가 아닌 곳에 마우스 올리면 일반 미리보기
            if (!aimedCoords || aimedCoords.x !== bx || aimedCoords.y !== by) {
              showPreview(bx, by, false);
            }
          });
          btn.addEventListener("mouseleave", () => {
            // 조준 중이면 조준 미리보기 복원, 아니면 숨김
            if (aimedCoords) {
              showPreview(aimedCoords.x, aimedCoords.y, true);
            } else {
              hidePreview();
            }
          });

          // 모바일 터치 이벤트
          btn.addEventListener("touchstart", (e) => {
            const rect = boardWrap.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
            const cellWidth = rect.width * step / 100;
            const cellHeight = rect.height * step / 100;
            const offsetX = rect.width * innerMin / 100;
            const offsetY = rect.height * innerMin / 100;
            const bx = Math.round((touchX - offsetX) / cellWidth);
            const by = Math.round((touchY - offsetY) / cellHeight);

            if (bx >= 0 && bx < SIZE && by >= 0 && by < SIZE) {
              touchCoords = {x: bx, y: by};
            }
          });

          btn.addEventListener("touchend", (e) => {
            if (touchCoords && !gameController.gameOver && gameController.isPlayerTurn()) {
              e.preventDefault();
              setAim(touchCoords.x, touchCoords.y);
              touchCoords = null;
            } else {
              touchCoords = null;
            }
          });

          btn.addEventListener("touchcancel", () => {
            touchCoords = null;
          });

          pointsLayer.appendChild(btn);
        }
      }
    }

    // 보드 렌더링
    function render() {
      const board = gameController.board;
      const lastMove = gameController.getLastMove();
      const innerMin = 8, innerMax = 92;
      const step = (innerMax - innerMin) / (SIZE - 1);

      stonesLayer.innerHTML = "";

      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const stone = board.get(x, y);
          if (stone === EMPTY) continue;

          const div = document.createElement("div");
          div.className = `stone ${stone}`;
          if (lastMove && lastMove.x === x && lastMove.y === y) {
            div.classList.add("last");
          }
          div.style.left = `${innerMin + x * step}%`;
          div.style.top = `${innerMin + y * step}%`;
          stonesLayer.appendChild(div);
        }
      }

      // 턴 표시
      const currentTurn = gameController.currentTurn;
      blackInfo.classList.toggle("current-turn", currentTurn === BLACK);
      whiteInfo.classList.toggle("current-turn", currentTurn === WHITE);

      // 금수 표시
      updateForbiddenMarks();
    }

    // 금수 마크 업데이트
    function updateForbiddenMarks() {
      const points = pointsLayer.querySelectorAll(".pt");
      points.forEach(pt => {
        const x = +pt.dataset.x;
        const y = +pt.dataset.y;
        if (playerColor === BLACK && gameController.board.isEmpty(x, y)) {
          if (OmokRules.isForbiddenMove(gameController.board, x, y, BLACK)) {
            pt.classList.add("forbidden");
          } else {
            pt.classList.remove("forbidden");
          }
        } else {
          pt.classList.remove("forbidden");
        }
      });
    }

    // 조준 해제
    function clearAim() {
      aimedCoords = null;
      hidePreview();
      confirmBtn.classList.remove("visible");
    }

    // 조준 설정
    function setAim(x, y) {
      // 같은 위치 클릭 시 해제
      if (aimedCoords && aimedCoords.x === x && aimedCoords.y === y) {
        clearAim();
        return;
      }

      // 유효한 수인지 확인
      if (!gameController.board.isEmpty(x, y)) {
        showToast("이미 착수된 위치입니다", "error");
        clearAim();
        return;
      }
      if (playerColor === BLACK && OmokRules.isForbiddenMove(gameController.board, x, y, BLACK)) {
        showToast("금수입니다", "error");
        clearAim();
        return;
      }

      aimedCoords = { x, y };
      showPreview(x, y, true);

      // 확인 버튼 위치 및 표시
      const innerMin = 8, innerMax = 92;
      const step = (innerMax - innerMin) / (SIZE - 1);
      const px = innerMin + x * step;
      const py = innerMin + y * step + 4;

      confirmBtn.style.left = px + "%";
      confirmBtn.style.top = py + "%";
      confirmBtn.classList.add("visible");

      // 좌우 가장자리 보정
      const wrap = document.getElementById("boardWrap");
      const btnW = confirmBtn.offsetWidth;
      const wrapW = wrap.offsetWidth;
      if (btnW && wrapW) {
        const halfBtnPct = (btnW / wrapW) * 50;
        const clampedPx = Math.max(halfBtnPct, Math.min(100 - halfBtnPct, px));
        confirmBtn.style.left = clampedPx + "%";
      }
    }

    // 포인트 클릭
    function onPointClick(e) {
      if (gameController.gameOver) return;
      if (!gameController.isPlayerTurn()) {
        showToast("AI 턴입니다", "info");
        return;
      }

      const x = +e.currentTarget.dataset.x;
      const y = +e.currentTarget.dataset.y;
      setAim(x, y);
    }

    // 착수 확인
    confirmBtn.addEventListener("click", () => {
      if (!aimedCoords) return;
      const { x, y } = aimedCoords;
      clearAim();

      // 플레이어 착수
      const result = gameController.playerMove(x, y);
      if (!result.success) {
        showToast(result.message, "error");
        return;
      }

      playStoneSound();
      render();

      if (result.win) {
        showGameOver(playerColor);
        return;
      }

      // AI 턴
      setTimeout(doAIMove, 300);
    });

    // AI 착수
    function doAIMove() {
      if (gameController.gameOver) return;
      if (gameController.isPlayerTurn()) return;

      aiThinking.classList.add("visible");

      // AI 계산 (비동기처럼 처리)
      setTimeout(() => {
        const move = gameController.aiMove();
        aiThinking.classList.remove("visible");

        if (!move) return;

        playStoneSound();
        render();

        if (move.win) {
          showGameOver(gameController.aiColor);
        }
      }, 500);
    }

    // 게임 종료 모달
    function showGameOver(winner) {
      const isPlayerWin = winner === playerColor;
      document.getElementById("resultTitle").textContent = isPlayerWin ? "승리!" : "패배";
      document.getElementById("winnerStone").textContent = winner === BLACK ? "●" : "○";
      document.getElementById("winnerName").textContent = isPlayerWin ? "플레이어 승리" : "AI 승리";
      gameOverModal.style.display = "flex";
    }

    // 다시하기
    function restart() {
      gameController.reset();
      aimedCoords = null;
      confirmBtn.classList.remove("visible");
      gameOverModal.style.display = "none";
      render();

      // 플레이어가 백이면 AI 먼저
      if (playerColor === WHITE) {
        setTimeout(doAIMove, 500);
      }
    }

    const restartConfirmModal = document.getElementById("restartConfirmModal");

    document.getElementById("restartBtn").addEventListener("click", () => {
      if (gameController && !gameController.gameOver && gameController.moveHistory.length > 0) {
        restartConfirmModal.style.display = "flex";
      } else {
        restart();
      }
    });

    document.getElementById("restartConfirmOk").addEventListener("click", () => {
      restartConfirmModal.style.display = "none";
      restart();
    });

    document.getElementById("restartConfirmCancel").addEventListener("click", () => {
      restartConfirmModal.style.display = "none";
    });

    document.getElementById("confirmResultBtn").addEventListener("click", () => {
      gameOverModal.style.display = "none";
    });

    // 로비 이동 버튼
    const lobbyBtn = document.getElementById("lobbyBtn");
    const lobbyConfirmModal = document.getElementById("lobbyConfirmModal");
    const lobbyUrl = "{% url 'games:lobby' %}";

    lobbyBtn.addEventListener("click", () => {
      // 게임이 진행 중이고 끝나지 않았으면 확인 모달 표시
      if (gameController && !gameController.gameOver && gameController.moveHistory.length > 0) {
        lobbyConfirmModal.style.display = "flex";
      } else {
        window.location.href = lobbyUrl;
      }
    });

    document.getElementById("lobbyConfirmCancel").addEventListener("click", () => {
      lobbyConfirmModal.style.display = "none";
    });

    document.getElementById("lobbyConfirmOk").addEventListener("click", () => {
      window.location.href = lobbyUrl;
    });

    // 테마 토글
    const themeToggle = document.getElementById("themeToggle");
    function updateThemeText() {
      const theme = document.documentElement.getAttribute("data-theme");
      themeToggle.textContent = theme === "dark" ? "라이트모드" : "다크모드";
    }
    updateThemeText();
    themeToggle.addEventListener("click", () => {
      const current = document.documentElement.getAttribute("data-theme");
      const next = current === "dark" ? "light" : "dark";
      document.documentElement.setAttribute("data-theme", next);
      localStorage.setItem("theme", next);
      updateThemeText();
    });

    // 토스트
    function showToast(message, type = "info") {
      const container = document.getElementById("toastContainer");
      const toast = document.createElement("div");
      toast.className = `toast ${type}`;
      toast.innerHTML = `<span>${message}</span>`;
      container.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    // 초기화
    drawGrid();
    createPoints();
    render();

    // 플레이어가 백이면 AI 먼저
    if (playerColor === WHITE) {
      setTimeout(doAIMove, 500);
    }

    // AI 게임 상태 하트비트 (로비에서 AI대전중 표시용)
    {% if user.is_authenticated %}
    const csrfToken = "{{ csrf_token }}";
    let aiHeartbeatInterval = null;

    function sendAiStatus() {
      fetch("{% url 'games:ai_game_status' %}", {
        method: "POST",
        headers: { "X-CSRFToken": csrfToken }
      }).catch(() => {});
    }

    function sendAiLeave() {
      fetch("{% url 'games:ai_game_leave' %}", {
        method: "POST",
        headers: { "X-CSRFToken": csrfToken }
      }).catch(() => {});
    }

    // 즉시 상태 전송 및 30초마다 하트비트
    sendAiStatus();
    aiHeartbeatInterval = setInterval(sendAiStatus, 30000);

    // 페이지 나갈 때 상태 해제
    window.addEventListener("beforeunload", () => {
      sendAiLeave();
      if (aiHeartbeatInterval) clearInterval(aiHeartbeatInterval);
    });

    // 로비로 이동 시 상태 해제 (모달 확인 후)
    const originalLobbyConfirmOk = document.getElementById("lobbyConfirmOk");
    if (originalLobbyConfirmOk) {
      originalLobbyConfirmOk.addEventListener("click", sendAiLeave, { once: true });
    }
    {% endif %}
  })();
  </script>

  <!-- Game BGM -->
  <audio id="bgm-game" loop preload="auto">
    <source src="{% static 'audio/game.mp3' %}" type="audio/mpeg">
  </audio>
  <script>
  (function() {
    const bgm = document.getElementById('bgm-game');
    const muteBtn = document.getElementById('bgm-mute-btn');
    let enabled = localStorage.getItem('bgm-enabled') !== 'false';
    const volume = parseFloat(localStorage.getItem('bgm-volume') || '0.3');

    function updateMuteBtn() {
      if (muteBtn) {
        muteBtn.textContent = enabled ? 'BGM OFF' : 'BGM ON';
        muteBtn.style.opacity = enabled ? '0.5' : '1';
      }
    }

    updateMuteBtn();

    if (muteBtn) {
      muteBtn.addEventListener('click', function() {
        enabled = !enabled;
        localStorage.setItem('bgm-enabled', enabled ? 'true' : 'false');
        updateMuteBtn();
        if (enabled) {
          bgm.volume = volume;
          bgm.play().catch(function(){});
        } else {
          bgm.pause();
        }
      });
    }

    if (!enabled || !bgm) return;
    bgm.volume = volume;
    if (sessionStorage.getItem('bgm-interacted')) {
      bgm.play().catch(function(){});
    } else {
      function start() {
        sessionStorage.setItem('bgm-interacted', '1');
        bgm.volume = volume;
        bgm.play().catch(function(){});
        document.removeEventListener('click', start);
        document.removeEventListener('touchstart', start);
        document.removeEventListener('keydown', start);
      }
      document.addEventListener('click', start);
      document.addEventListener('touchstart', start);
      document.addEventListener('keydown', start);
    }
  })();
  </script>

  {% include "includes/heartbeat.html" %}
</body>
</html>