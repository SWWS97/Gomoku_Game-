<!doctype html>
<html>
<head>
  <script>
    (function() {
      const theme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>오목조목 {{ game.id }}</title>
  <style>
    :root{
      --cell: 44px;
      --margin: 30px;
      --wood: #d4b781;
      --line: #7b5c3a;
      --border: #3e2a1f;
      --bg: #faf7f2;
      --topbar-bg: #fff;
      --topbar-border: #b08f66;
      --player-bg: #fff;
      --player-border: #ccc;
      --text: #333;
      --text-secondary: #666;
      --modal-bg: #fff;
      --timer-bg: rgba(255,255,255,0.95);
      --timer-border: #d4b781;
      --quick-chat-bg: white;
      --quick-chat-border: var(--line);
      --toast-bg: white;
    }

    /* 다크모드 */
    [data-theme="dark"] {
      --wood: #2a2520;
      --line: #4a4035;
      --border: #4ade80;
      --bg: #0f0f1a;
      --topbar-bg: #16213e;
      --topbar-border: #4ade80;
      --player-bg: #1e293b;
      --player-border: #374151;
      --text: #e5e7eb;
      --text-secondary: #9ca3af;
      --modal-bg: #16213e;
      --timer-bg: rgba(22, 33, 62, 0.95);
      --timer-border: #4ade80;
      --quick-chat-bg: #1e293b;
      --quick-chat-border: #374151;
      --toast-bg: #1e293b;
    }

    html, body { height:100%; margin:0; background:var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, sans-serif; }

    /* ===== Top bar ===== */
    .topbar{
      display:flex; align-items:center; gap:14px;
      padding:12px 16px 6px; font-weight:700;
      color: var(--text);
      transition: color 0.3s ease;
    }
    .topbar .right{ margin-left:auto; display:flex; gap:14px; align-items:center; }
    .pill{
      padding:.45rem .9rem; border:1.5px solid var(--topbar-border); border-radius:.6rem;
      background:var(--topbar-bg); cursor:pointer; color:var(--text);
      font-size:0.85rem; font-weight:700; text-decoration:none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.15s ease;
    }
    .pill:hover{ transform:translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
    .pill:active{ transform:translateY(0); box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
    [data-theme="dark"] .pill{ box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
    [data-theme="dark"] .pill:hover{ box-shadow: 0 4px 10px rgba(0,0,0,0.4); }
    .pill.theme-toggle{ background: linear-gradient(135deg, #374151, #1f2937); color: #fff; border-color: #374151; }
    [data-theme="dark"] .pill.theme-toggle{ background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1f2937; border-color: #fbbf24; }
    .players{ display:flex; gap:16px; }
    .player-info{ padding:.4rem .7rem; border:1px solid var(--player-border); border-radius:.4rem; background:var(--player-bg); font-size:.9rem; color:var(--text); transition: background 0.3s ease, border-color 0.3s ease, color 0.3s ease; }
    .player-info .label{ color:var(--text-secondary); font-size:.8rem; }

    /* ===== 타이머 (상단 중앙) ===== */
    .timer-container{
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 40px;
      background: var(--timer-bg);
      padding: 1rem 2rem;
      border-radius: 0.8rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: 2px solid var(--timer-border);
      z-index: 10;
      transition: background 0.3s ease, border-color 0.3s ease;
    }
    .timer-item{
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.3rem;
    }
    .timer-label{
      font-size: 0.85rem;
      color: var(--text-secondary);
      font-weight: 600;
    }
    .timer-value{
      font-size: 1.8rem;
      font-weight: 900;
      font-family: 'Courier New', monospace;
      letter-spacing: 0.05em;
    }
    .timer-value.black{ color: #2b2b2b; }
    .timer-value.white{ color: #5a5a5a; }
    .timer-value.active{
      color: #d84315;
      animation: timerPulse 1s ease-in-out infinite;
    }
    .timer-value.warning{
      color: #d84315 !important;
    }
    @keyframes timerPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* 승자 배지(상단 표시) */
    .winner-badge{
      display:none;  /* 기본 숨김, 승자 나오면 보여줌 */
      padding:.25rem .55rem;
      border-radius:.6rem;
      border:1px solid #d5b2a8;
      background:#fff4ef;
      color:#7a2e2e;
      font-weight:800;
      font-size:1.12rem;  /* 요청: 살짝 크게 */
      box-shadow: 0 1px 0 rgba(255,255,255,.6) inset;
    }

    /* ===== 게임 종료 모달 ===== */
    .game-over-modal{
      display:none;
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,0.6);
      z-index:1000;
      align-items:center;
      justify-content:center;
    }
    .modal-content{
      background:var(--modal-bg);
      padding:2.5rem 3rem;
      border-radius:1rem;
      box-shadow:0 10px 40px rgba(0,0,0,0.3);
      text-align:center;
      max-width:400px;
      animation: modalFadeIn 0.3s ease;
      color: var(--text);
      transition: background 0.3s ease, color 0.3s ease;
    }

    [data-theme="dark"] .modal-content {
      border: 2px solid #374151;
    }

    [data-theme="dark"] .modal-content h2 {
      color: #4ade80;
    }

    [data-theme="dark"] .modal-content p {
      color: var(--text-secondary) !important;
    }
    @keyframes modalFadeIn {
      from { opacity:0; transform:translateY(-20px); }
      to { opacity:1; transform:translateY(0); }
    }
    .modal-content h2{
      margin:0 0 1rem;
      font-size:1.8rem;
      color:#7a2e2e;
    }
    .modal-content .winner-name{
      font-size:2.2rem;
      font-weight:900;
      margin:1rem 0;
      color:#2b2b2b;
    }
    .modal-content .winner-stone{
      font-size:3rem;
      margin:0.5rem 0;
    }
    .modal-content .modal-btn{
      margin-top:1.5rem;
      padding:0.75rem 2rem;
      background:#7a2e2e;
      color:#fff;
      border:none;
      border-radius:0.5rem;
      font-size:1rem;
      font-weight:700;
      cursor:pointer;
      transition:background 0.2s;
    }
    .modal-content .modal-btn:hover{
      background:#5a1e1e;
    }

    /* ===== Board ===== */
    .board-wrap{
      position:relative;
      width: calc(({{ BOARD_SIZE }} - 1) * var(--cell) + 2 * var(--margin));
      height: calc(({{ BOARD_SIZE }} - 1) * var(--cell) + 2 * var(--margin));
      border: 6px solid var(--border);
      background:
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 35px,
          rgba(0,0,0,.03) 35px,
          rgba(0,0,0,.03) 36px
        ),
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 80px,
          rgba(0,0,0,.02) 80px,
          rgba(0,0,0,.02) 81px
        ),
        linear-gradient(160deg, #e8c882 0%, #d4b781 30%, #c9a86c 60%, #d4b781 100%);
      border-radius: 6px;
      box-shadow:
        0 18px 26px rgba(0,0,0,.25),
        inset 0 1px 0 rgba(255,255,255,.25),
        inset 0 0 20px rgba(0,0,0,.06);
      overflow: visible;
      margin: 10px auto 36px;
    }
    [data-theme="dark"] .board-wrap{
      background:
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 35px,
          rgba(255,255,255,.02) 35px,
          rgba(255,255,255,.02) 36px
        ),
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 80px,
          rgba(255,255,255,.015) 80px,
          rgba(255,255,255,.015) 81px
        ),
        linear-gradient(160deg, #342e28 0%, #2a2520 30%, #221e19 60%, #2a2520 100%);
      box-shadow:
        0 18px 26px rgba(0,0,0,.5),
        inset 0 1px 0 rgba(255,255,255,.05),
        inset 0 0 20px rgba(0,0,0,.15);
    }
    .grid{ position:absolute; inset:0; display:block; }
    .layer{ position:absolute; inset:0; pointer-events:none; }

    .pt{
      position:absolute; width:var(--cell); height:var(--cell);
      transform: translate(-50%, -50%);
      pointer-events:auto; background:transparent; border:none; padding:0; cursor:pointer;
      -webkit-tap-highlight-color: transparent; /* 모바일 기본 하이라이트 제거 */
    }
    .pt:hover::after{
      content:""; position:absolute; left:50%; top:50%;
      width:18px; height:18px; transform:translate(-50%,-50%);
      border-radius:50%;
      background: radial-gradient(circle at 35% 35%, rgba(0,0,0,.18), rgba(0,0,0,0) 60%);
    }
    /* 모바일 터치 피드백 */
    .pt:active::after{
      content:""; position:absolute; left:50%; top:50%;
      width:28px; height:28px; transform:translate(-50%,-50%);
      border-radius:50%;
      background: radial-gradient(circle at 35% 35%, rgba(74, 124, 89, .5), rgba(74, 124, 89, 0) 60%);
    }

    .stone{
      position:absolute; width:5.6%; height:5.6%; transform:translate(-50%,-50%); border-radius:50%;
      pointer-events:none; filter: drop-shadow(0 3px 4px rgba(0,0,0,.4));
    }
    .stone.black{
      background:
        radial-gradient(circle at 32% 26%, rgba(255,255,255,.12) 0%, transparent 40%),
        radial-gradient(circle at 30% 28%, #4a4a4a 0%, #262626 45%, #0f0f0f 70%),
        radial-gradient(circle at 68% 74%, rgba(255,255,255,.15), rgba(255,255,255,0) 55%);
      box-shadow: inset 1px 1px 4px rgba(255,255,255,.1), inset -7px -7px 14px rgba(0,0,0,.6);
    }
    .stone.white{
      background:
        radial-gradient(circle at 32% 26%, rgba(255,255,255,.95) 0%, transparent 35%),
        radial-gradient(circle at 30% 28%, #ffffff 0%, #f1f1f1 45%, #e2e2e2 70%),
        radial-gradient(circle at 68% 78%, rgba(0,0,0,.1), rgba(0,0,0,0) 55%);
      box-shadow: inset 1px 1px 3px rgba(255,255,255,.8), inset -7px -7px 14px rgba(0,0,0,.1);
    }

    /* 미리보기 돌 (조준점) */
    .stone.preview{
      opacity: 0.5;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.2));
    }
    .stone.preview.aimed{
      opacity: 0.7;
      filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8)) drop-shadow(0 2px 4px rgba(0,0,0,.3));
      animation: aimPulse 1.2s ease-in-out infinite;
    }
    @keyframes aimPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 0.55; }
    }

    /* 착수 확인 버튼 */
    .confirm-move-btn{
      display: none;
      position: absolute;
      left: 50%;
      bottom: -5px;
      transform: translateX(-50%);
      z-index: 200;
      padding: 8px 32px;
      font-size: 1rem;
      font-weight: 800;
      letter-spacing: 2px;
      color: #fff;
      background: linear-gradient(135deg, #43a047, #2e7d32);
      border: none;
      border-radius: 20px;
      cursor: pointer;
      box-shadow: 0 3px 10px rgba(46, 125, 50, 0.4), inset 0 1px 0 rgba(255,255,255,0.2);
      transition: all 0.15s ease;
    }
    .confirm-move-btn:hover{
      transform: translateX(-50%) translateY(-2px);
      box-shadow: 0 5px 16px rgba(46, 125, 50, 0.5), inset 0 1px 0 rgba(255,255,255,0.2);
      background: linear-gradient(135deg, #4caf50, #388e3c);
    }
    .confirm-move-btn:active{
      transform: translateX(-50%) translateY(0) scale(0.97);
      box-shadow: 0 1px 4px rgba(46, 125, 50, 0.3);
    }
    .confirm-move-btn.visible{
      display: block;
      animation: confirmAppear 0.2s ease-out;
    }
    @keyframes confirmAppear {
      from { opacity: 0; transform: translateX(-50%) translateY(6px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    [data-theme="dark"] .confirm-move-btn{
      background: linear-gradient(135deg, #4ade80, #22c55e);
      color: #0f172a;
      box-shadow: 0 3px 10px rgba(74, 222, 128, 0.35), inset 0 1px 0 rgba(255,255,255,0.15);
    }
    [data-theme="dark"] .confirm-move-btn:hover{
      background: linear-gradient(135deg, #6ee7b7, #34d399);
      box-shadow: 0 5px 16px rgba(74, 222, 128, 0.45), inset 0 1px 0 rgba(255,255,255,0.15);
    }

    /* 착수 애니메이션 */
    .stone.new-move {
      animation: stoneDrop 0.25s ease-out;
    }
    @keyframes stoneDrop {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.3; }
      70% { transform: translate(-50%, -50%) scale(1.08); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    /* 마지막 착수 강조 애니메이션 */
    .stone.last-move {
      animation: stonePulse 1.5s ease-in-out 3;
    }
    @keyframes stonePulse {
      0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 3px 4px rgba(0,0,0,.4));
      }
      50% {
        transform: translate(-50%, -50%) scale(1.15);
        filter: drop-shadow(0 0 12px rgba(255, 215, 0, 0.8)) drop-shadow(0 3px 4px rgba(0,0,0,.4));
      }
    }

    /* ===== 리매치 대기 점 애니메이션 ===== */
    .dots::after {
      content: '';
      animation: dots 1.5s steps(4, end) infinite;
    }
    @keyframes dots {
      0%, 25% { content: '.'; }
      26%, 50% { content: '..'; }
      51%, 75% { content: '...'; }
      76%, 100% { content: ''; }
    }

    /* ===== 리매치 아이콘 디자인 (loading-spinner와 동일) ===== */
    .rematch-icon {
      width: 70px;
      height: 70px;
      position: relative;
      margin: 1rem auto;
      animation: spin 1.2s linear infinite;
    }
    .rematch-icon::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 5px solid #e0e0e0;
      border-radius: 50%;
      border-top-color: #4a7c59;
      border-right-color: #4a7c59;
    }
    .rematch-icon::after {
      content: '';
      position: absolute;
      top: -3px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 12px solid #4a7c59;
    }

    /* 로딩 스피너 (리매치 대기) */
    .loading-spinner {
      width: 70px;
      height: 70px;
      position: relative;
      margin: 1rem auto;
      animation: spin 1.2s linear infinite;
    }
    .loading-spinner::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 5px solid #e0e0e0;
      border-radius: 50%;
      border-top-color: #4a7c59;
      border-right-color: #4a7c59;
    }
    /* 화살표 머리 */
    .loading-spinner::after {
      content: '';
      position: absolute;
      top: -3px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 12px solid #4a7c59;
      border-radius: 50%;
      border-bottom-color: #6b9477;
      border-left-color: #6b9477;
      animation: spin 1.8s linear infinite reverse;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ===== 모바일 반응형 ===== */
    @media (max-width: 768px) {
      /* 상단 바 */
      .topbar{
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px 12px;
        font-size: 0.85rem;
      }
      .topbar .right{
        width: 100%;
        justify-content: flex-start;
        gap: 8px;
        margin-top: 8px;
      }
      .pill{
        padding: 0.35rem 0.7rem;
        font-size: 0.78rem;
      }
      .players{
        gap: 8px;
        flex-wrap: wrap;
      }
      .player-info{
        padding: 0.3rem 0.5rem;
        font-size: 0.75rem;
      }

      /* 타이머: absolute 해제하고 topbar 아래에 자연스럽게 배치 */
      .timer-container{
        position: static;
        transform: none;
        gap: 20px;
        padding: 0.5rem 1rem;
        margin: 4px 0 0;
        justify-content: center;
        width: auto;
        box-sizing: border-box;
      }
      .timer-label{
        font-size: 0.7rem;
      }
      .timer-value{
        font-size: 1.2rem;
      }

      /* 승자 배지 */
      .winner-badge{
        font-size: 0.9rem;
        padding: 0.2rem 0.4rem;
      }

      /* 게임판 - 모바일에서 최대한 크게 */
      .board-wrap{
        width: calc(100vw - 8px);
        max-width: 540px;
        height: calc(100vw - 8px);
        max-height: 540px;
        margin: 6px auto 16px;
        border: 5px solid var(--border);
      }

      /* 모달 */
      .modal-content{
        padding: 1.5rem 2rem;
        max-width: 90%;
      }
      .modal-content h2{
        font-size: 1.4rem;
      }
      .modal-content .winner-name{
        font-size: 1.8rem;
      }
      .modal-content .winner-stone{
        font-size: 2.5rem;
      }
      .modal-content .modal-btn{
        padding: 0.6rem 1.5rem;
        font-size: 0.9rem;
      }

      /* 터치 영역 확대 (클릭하기 쉽게) */
      .pt{
        width: calc(var(--cell) * 1.5);
        height: calc(var(--cell) * 1.5);
        min-width: 44px;
        min-height: 44px;
      }
    }

    /* 초소형 모바일 (아이폰 SE 등) */
    @media (max-width: 375px) {
      .topbar{
        font-size: 0.75rem;
      }
      .timer-container{
        gap: 15px;
        padding: 0.4rem 0.8rem;
      }
      .timer-value{
        font-size: 1rem;
      }
      .board-wrap{
        margin-top: 10px;
      }
      .modal-content{
        padding: 1rem 1.5rem;
      }
      .modal-content h2{
        font-size: 1.2rem;
      }
      .modal-content .winner-name{
        font-size: 1.5rem;
      }
    }

    /* 폴더블 폰 접힌 화면 (갤럭시 폴드 등 ~320px) */
    @media (max-width: 320px) {
      .timer-container{
        gap: 10px;
        padding: 0.3rem 0.6rem;
      }
      .timer-label{
        font-size: 0.7rem;
      }
      .timer-value{
        font-size: 0.9rem;
      }
      .board-wrap{
        width: calc(100vw - 6px);
        height: calc(100vw - 6px);
        margin-top: 6px;
        border: 3px solid var(--border);
      }
      .pt{
        width: calc(var(--cell) * 1.2);
        height: calc(var(--cell) * 1.2);
        min-width: 36px;
        min-height: 36px;
      }
      .pt:hover::after, .pt:active::after{
        width: 14px;
        height: 14px;
      }
    }

    /* 태블릿 가로 모드 */
    @media (min-width: 769px) and (max-width: 1024px) {
      .board-wrap{
        width: 660px;
        height: 660px;
      }
    }

    /* ===== 빠른 채팅 ===== */
    .quick-chat-container {
      display: none; /* 기본 숨김, 토글 버튼으로 제어 */
      position: fixed;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      flex-direction: column;
      min-width: 240px;
      max-width: 260px;
      z-index: 100;
    }
    .quick-chat-container.active {
      display: flex;
    }
    .quick-chat-panel {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .quick-chat-btn {
      padding: 12px 8px;
      background: var(--quick-chat-bg);
      border: 2px solid var(--quick-chat-border);
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      word-wrap: break-word;
    }
    .quick-chat-btn:hover {
      background: var(--wood);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    [data-theme="dark"] .quick-chat-btn:hover {
      background: #374151;
      border-color: #4ade80;
    }
    .quick-chat-btn:active {
      transform: translateY(0);
    }

    /* 말풍선 - 오목판 오른쪽에 표시 */
    .chat-bubble {
      position: fixed;
      top: 50%;
      right: 80px;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.98);
      border: 3px solid var(--border);
      border-radius: 20px;
      padding: 20px 30px;
      font-size: 1.6rem;
      font-weight: 900;
      color: var(--border);
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 2000;
      animation: bubbleSlideIn 0.3s ease-out;
      pointer-events: none;
      max-width: 280px;
      word-wrap: break-word;
    }
    /* 흑돌 플레이어 말풍선 */
    .chat-bubble.black {
      background: rgba(50, 50, 50, 0.95);
      border: 3px solid #1a1a1a;
      color: white;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
    }
    /* 백돌 플레이어 말풍선 */
    .chat-bubble.white {
      background: rgba(255, 255, 255, 0.98);
      border: 3px solid #d4b781;
      color: var(--border);
      box-shadow: 0 8px 24px rgba(212, 183, 129, 0.5);
    }
    @keyframes bubbleSlideIn {
      0% {
        opacity: 0;
        transform: translateY(-50%) translateX(20px);
      }
      100% {
        opacity: 1;
        transform: translateY(-50%) translateX(0);
      }
    }

    /* 모바일 반응형 */
    @media (max-width: 1024px) {
      /* 빠른 채팅 토글 버튼: topbar 내에서 다크모드 옆에 위치 */
      #quick-chat-toggle-btn {
        position: static !important;
        transform: none;
        z-index: auto;
        padding: 0.35rem 0.7rem;
        font-size: 0.78rem;
        white-space: nowrap;
      }

      /* 빠른 채팅 선택지를 오목판 아래에 표시 */
      .quick-chat-container {
        position: fixed;
        left: 50%;
        bottom: 20px;
        top: auto;
        transform: translateX(-50%);
        min-width: 90vw;
        max-width: 90vw;
        max-height: 40vh;
        overflow-y: auto;
        width: auto;
        margin: 0;
        background: rgba(255, 255, 255, 0.95);
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }

      [data-theme="dark"] .quick-chat-container {
        background: rgba(30, 41, 59, 0.95);
      }

      .quick-chat-panel {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .quick-chat-btn {
        font-size: 0.75rem;
        padding: 10px 8px;
        margin-bottom: 0;
      }

      /* 말풍선: 오목판 위쪽에 표시 */
      .chat-bubble {
        position: fixed;
        left: 50%;
        top: 120px;
        right: auto;
        transform: translateX(-50%);
        font-size: 1.3rem;
        padding: 15px 25px;
        max-width: 80%;
      }
      @keyframes bubbleSlideIn {
        0% {
          opacity: 0;
          transform: translateX(-50%) translateY(-20px);
        }
        100% {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }
    }

    @media (max-width: 768px) {
      .quick-chat-btn {
        font-size: 0.75rem;
        padding: 10px 6px;
      }
      .quick-chat-title {
        font-size: 0.9rem;
      }
      .chat-bubble {
        font-size: 1.2rem;
        padding: 12px 20px;
      }
    }

    /* 토스트 알림 스타일 */
    .toast-container {
      position: fixed;
      top: 80px;
      right: 20px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 400px;
    }

    .toast {
      background: var(--toast-bg);
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      border-left: 4px solid;
      display: flex;
      align-items: center;
      gap: 12px;
      animation: slideIn 0.3s ease-out;
      min-width: 300px;
      color: var(--text);
      transition: background 0.3s ease, color 0.3s ease;
    }

    .toast.success {
      border-left-color: #4a7c59;
      background: linear-gradient(135deg, #f0f9f4 0%, #ffffff 100%);
    }

    [data-theme="dark"] .toast.success {
      background: linear-gradient(135deg, rgba(74, 222, 128, 0.1) 0%, #1e293b 100%);
      border-left-color: #4ade80;
    }

    .toast.error {
      border-left-color: #c53030;
      background: linear-gradient(135deg, #fef5f5 0%, #ffffff 100%);
    }

    [data-theme="dark"] .toast.error {
      background: linear-gradient(135deg, rgba(248, 113, 113, 0.1) 0%, #1e293b 100%);
      border-left-color: #f87171;
    }

    .toast.info {
      border-left-color: #4a7c89;
      background: linear-gradient(135deg, #f0f7f9 0%, #ffffff 100%);
    }

    [data-theme="dark"] .toast.info {
      background: linear-gradient(135deg, rgba(74, 124, 137, 0.1) 0%, #1e293b 100%);
      border-left-color: #67b7c8;
    }

    .toast-icon {
      font-size: 24px;
      flex-shrink: 0;
    }

    .toast.success .toast-icon {
      color: #4a7c59;
    }

    .toast.error .toast-icon {
      color: #c53030;
    }

    .toast.info .toast-icon {
      color: #4a7c89;
    }

    .toast-content {
      flex: 1;
    }

    .toast-message {
      color: var(--text);
      font-size: 14px;
      line-height: 1.5;
      font-weight: 500;
    }

    .toast-close {
      background: none;
      border: none;
      color: #999;
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .toast-close:hover {
      background: rgba(0, 0, 0, 0.05);
      color: #333;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(400px);
        opacity: 0;
      }
    }

    .toast.slide-out {
      animation: slideOut 0.3s ease-out forwards;
    }

    @media (max-width: 768px) {
      .toast-container {
        top: 60px;
        right: 10px;
        left: 10px;
        max-width: none;
      }

      .toast {
        min-width: auto;
        width: 100%;
        padding: 12px 16px;
      }

      .toast-icon {
        font-size: 20px;
      }

      .toast-message {
        font-size: 13px;
      }
    }

    /* ===== 롤 스타일 티어 뱃지 ===== */
    .tier-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
      padding: 3px 8px;
      border-radius: 5px;
      font-size: 0.7rem;
      font-weight: 800;
      white-space: nowrap;
      vertical-align: middle;
      position: relative;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.3),
        inset 0 -1px 0 rgba(0,0,0,0.2),
        0 2px 4px rgba(0,0,0,0.2);
      border: 1px solid rgba(0,0,0,0.1);
      letter-spacing: 0.5px;
    }
    .tier-badge::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 50%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.2), transparent);
      border-radius: 4px 4px 0 0;
      pointer-events: none;
    }
    .tier-badge .tier-icon {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));
    }
    .tier-badge .tier-icon svg { width: 100%; height: 100%; }

    /* 급 티어 */
    .tier-badge.tier-5급 { background: linear-gradient(135deg, #8b7355 0%, #6b5344 50%, #8b7355 100%); color: #f5e6d3; border-color: #5a4535; }
    .tier-badge.tier-4급 { background: linear-gradient(135deg, #9a8a7a 0%, #7a6a5a 50%, #9a8a7a 100%); color: #fff5eb; border-color: #6a5a4a; }
    .tier-badge.tier-3급 { background: linear-gradient(135deg, #a8a8a8 0%, #888888 50%, #a8a8a8 100%); color: #ffffff; border-color: #707070; }
    .tier-badge.tier-2급 { background: linear-gradient(135deg, #c0c0c0 0%, #a0a0a0 50%, #c0c0c0 100%); color: #ffffff; border-color: #909090; }
    .tier-badge.tier-1급 { background: linear-gradient(135deg, #d4d4d4 0%, #b8b8b8 50%, #d4d4d4 100%); color: #ffffff; border-color: #a0a0a0; text-shadow: 0 1px 2px rgba(0,0,0,0.4); }

    /* 단 티어 */
    .tier-badge.tier-1단 { background: linear-gradient(135deg, #c9a227 0%, #a68523 50%, #c9a227 100%); color: #fff8dc; border-color: #8b7500; }
    .tier-badge.tier-2단 { background: linear-gradient(135deg, #daa520 0%, #b8860b 50%, #daa520 100%); color: #fffacd; border-color: #996515; }
    .tier-badge.tier-3단 { background: linear-gradient(135deg, #ffd700 0%, #daa520 50%, #ffd700 100%); color: #ffffff; border-color: #b8860b; text-shadow: 0 1px 2px rgba(0,0,0,0.5); }

    /* 고급 티어 */
    .tier-badge.tier-낭인 { background: linear-gradient(135deg, #4fc3c7 0%, #26a69a 50%, #4fc3c7 100%); color: #e0ffff; border-color: #1a8a7e; }
    .tier-badge.tier-달인 { background: linear-gradient(135deg, #00bcd4 0%, #0097a7 50%, #00bcd4 100%); color: #e0ffff; border-color: #007687; }
    .tier-badge.tier-명인 { background: linear-gradient(135deg, #7c4dff 0%, #651fff 50%, #7c4dff 100%); color: #e8e0ff; border-color: #5000e0; }

    /* 최상위 티어 */
    .tier-badge.tier-지존 { background: linear-gradient(135deg, #e040fb 0%, #aa00ff 50%, #e040fb 100%); color: #ffe0ff; border-color: #8800cc; }
    .tier-badge.tier-패왕 { background: linear-gradient(135deg, #ff5252 0%, #d32f2f 50%, #ff5252 100%); color: #ffe0e0; border-color: #b71c1c; }
    .tier-badge.tier-투신 { background: linear-gradient(135deg, #ff1744 0%, #c51162 50%, #ff1744 100%); color: #ffffff; border-color: #ab003c; animation: tier-glow-red 2s ease-in-out infinite; }
    .tier-badge.tier-무신 {
      background: linear-gradient(135deg, #ffd54f 0%, #ffab00 25%, #ff6f00 50%, #ffab00 75%, #ffd54f 100%);
      background-size: 200% 200%;
      color: #ffffff;
      border: 2px solid #ffd700;
      text-shadow: 0 0 10px rgba(255,215,0,0.8), 0 1px 2px rgba(0,0,0,0.5);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.4), inset 0 -1px 0 rgba(0,0,0,0.2), 0 0 15px rgba(255,215,0,0.5), 0 2px 4px rgba(0,0,0,0.3);
      animation: tier-shine 3s linear infinite;
    }
    .tier-badge.tier-placement { background: linear-gradient(135deg, #607d8b 0%, #455a64 50%, #607d8b 100%); color: #eceff1; border-color: #37474f; }

    @keyframes tier-shine { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
    @keyframes tier-glow-red { 0%, 100% { box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), inset 0 -1px 0 rgba(0,0,0,0.2), 0 0 8px rgba(255,23,68,0.4); } 50% { box-shadow: inset 0 1px 0 rgba(255,255,255,0.3), inset 0 -1px 0 rgba(0,0,0,0.2), 0 0 15px rgba(255,23,68,0.7); } }

    /* ===== 배치 완료 / 티어 변동 모달 아이콘 ===== */
    .placement-icon {
      width: 80px; height: 80px;
      margin: 0 auto 1rem;
      position: relative;
    }
    .placement-icon .shield {
      width: 70px; height: 80px;
      background: linear-gradient(135deg, #ffd700 0%, #ffab00 50%, #ff8f00 100%);
      clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
      position: absolute; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 4px 15px rgba(255, 193, 7, 0.5);
      animation: shield-pulse 2s ease-in-out infinite;
    }
    .placement-icon .shield::before {
      content: ''; position: absolute;
      top: 8px; left: 8px; right: 8px; bottom: 8px;
      background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
      clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    }
    .placement-icon .shield::after {
      content: '★'; position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 28px; color: #ff8f00;
      text-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .placement-icon .sparkle {
      position: absolute; width: 8px; height: 8px;
      background: #ffd700; border-radius: 50%;
      animation: sparkle 1.5s ease-in-out infinite;
    }
    .placement-icon .sparkle:nth-child(2) { top: 5px; left: 15px; animation-delay: 0s; }
    .placement-icon .sparkle:nth-child(3) { top: 10px; right: 10px; animation-delay: 0.3s; }
    .placement-icon .sparkle:nth-child(4) { bottom: 15px; left: 10px; animation-delay: 0.6s; }
    .placement-icon .sparkle:nth-child(5) { bottom: 10px; right: 15px; animation-delay: 0.9s; }

    @keyframes shield-pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.05); }
    }
    @keyframes sparkle {
      0%, 100% { opacity: 0; transform: scale(0); }
      50% { opacity: 1; transform: scale(1); }
    }

    /* 티어 승급 아이콘 */
    .promotion-icon {
      width: 80px; height: 80px;
      margin: 0 auto 1rem;
      position: relative;
    }
    .promotion-icon .arrow-up {
      width: 0; height: 0;
      border-left: 25px solid transparent;
      border-right: 25px solid transparent;
      border-bottom: 40px solid #4caf50;
      position: absolute; left: 50%; top: 10px;
      transform: translateX(-50%);
      filter: drop-shadow(0 4px 8px rgba(76, 175, 80, 0.4));
      animation: arrow-bounce-up 1s ease-in-out infinite;
    }
    .promotion-icon .arrow-up::after {
      content: '';
      position: absolute; top: 40px; left: -10px;
      width: 20px; height: 30px;
      background: #4caf50;
    }
    .promotion-icon .glow-ring {
      position: absolute; top: 50%; left: 50%;
      width: 70px; height: 70px;
      border: 3px solid #4caf50;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      animation: glow-expand 1.5s ease-out infinite;
    }
    .promotion-icon .glow-ring:nth-child(2) { animation-delay: 0.5s; }

    @keyframes arrow-bounce-up {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-8px); }
    }
    @keyframes glow-expand {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
    }

    /* 티어 강등 아이콘 */
    .demotion-icon {
      width: 80px; height: 80px;
      margin: 0 auto 1rem;
      position: relative;
    }
    .demotion-icon .arrow-down {
      width: 0; height: 0;
      border-left: 25px solid transparent;
      border-right: 25px solid transparent;
      border-top: 40px solid #e53935;
      position: absolute; left: 50%; bottom: 10px;
      transform: translateX(-50%);
      filter: drop-shadow(0 4px 8px rgba(229, 57, 53, 0.4));
      animation: arrow-bounce-down 1s ease-in-out infinite;
    }
    .demotion-icon .arrow-down::before {
      content: '';
      position: absolute; bottom: 40px; left: -10px;
      width: 20px; height: 30px;
      background: #e53935;
    }
    .demotion-icon .crack {
      position: absolute; top: 50%; left: 50%;
      width: 60px; height: 60px;
      transform: translate(-50%, -50%);
    }
    .demotion-icon .crack::before, .demotion-icon .crack::after {
      content: ''; position: absolute;
      background: #ffcdd2; border-radius: 2px;
    }
    .demotion-icon .crack::before {
      width: 3px; height: 25px; top: 5px; left: 20px;
      transform: rotate(-20deg);
    }
    .demotion-icon .crack::after {
      width: 3px; height: 20px; top: 15px; left: 35px;
      transform: rotate(15deg);
    }

    @keyframes arrow-bounce-down {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(8px); }
    }

    /* 티어 변동 화살표 */
    .tier-arrow {
      display: flex; align-items: center; justify-content: center;
      width: 50px; height: 50px;
    }
    .tier-arrow svg {
      width: 40px; height: 40px;
    }
    .tier-arrow.promotion svg { color: #4caf50; animation: arrow-pulse 1s ease-in-out infinite; }
    .tier-arrow.demotion svg { color: #e53935; animation: arrow-pulse 1s ease-in-out infinite; }

    @keyframes arrow-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    /* 신고 모달 */
    .report-modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .report-modal.active {
      display: flex;
    }

    .report-modal .report-content {
      background: var(--modal-bg);
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      animation: modalFadeIn 0.3s ease;
    }

    .report-modal .report-content h3 {
      margin: 0 0 6px;
      font-size: 1.2rem;
      color: var(--text);
    }

    .report-modal .report-target {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 16px;
    }

    .report-modal label {
      display: block;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 6px;
    }

    .report-modal select,
    .report-modal textarea {
      width: 100%;
      padding: 8px 10px;
      border: 2px solid var(--player-border);
      border-radius: 6px;
      font-size: 14px;
      background: var(--player-bg);
      color: var(--text);
      margin-bottom: 14px;
      box-sizing: border-box;
    }

    .report-modal select:focus,
    .report-modal textarea:focus {
      outline: none;
      border-color: var(--topbar-border);
    }

    .report-modal textarea {
      resize: vertical;
      min-height: 70px;
    }

    .report-modal .report-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .report-modal .report-actions button {
      padding: 8px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }

    .report-modal .btn-report-cancel {
      background: #6b7280;
      color: #fff;
    }

    .report-modal .btn-report-submit {
      background: #ef4444;
      color: #fff;
    }

    .report-modal .btn-report-submit:hover {
      background: #dc2626;
    }

    [data-theme="dark"] .report-modal .report-content {
      border: 1px solid #374151;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div>{{ game.title }}</div>
    <div id="ws-state">게임 연결 중…</div>

    <!-- 플레이어 정보 -->
    <div class="players">
      <div class="player-info">
        <span class="label">흑(●):</span>
        <span id="black-tier"></span>
        <span id="black-player">대기중...</span>
      </div>
      <div class="player-info">
        <span class="label">백(○):</span>
        <span id="white-tier"></span>
        <span id="white-player">대기중...</span>
      </div>
    </div>

    <!-- 여기! 상단 우측에 승자 배지 -->
    <div id="winnerTop" class="winner-badge"></div>

    <div class="right">
      <div id="turn"></div>
      <button class="pill" id="quick-chat-toggle-btn" style="display:none; background:linear-gradient(135deg, #6a9fb5, #5a8fa5); border-color:#5a8fa5; color:#fff;">빠른 채팅</button>
      <a href="{% url 'games:leave' pk=game.pk %}" class="pill" id="leave-btn" style="display:none; background:linear-gradient(135deg, #888, #777); border-color:#666; color:#fff;">나가기</a>
      <button class="pill" id="surrender-btn" style="display:none; background:linear-gradient(135deg, #e05555, #c44); border-color:#a33; color:#fff;">항복</button>
      <button class="pill" id="report-btn" style="display:none; background:linear-gradient(135deg, #f87171, #ef4444); border-color:#dc2626; color:#fff;">신고</button>
      <button class="pill" id="rematch-btn" style="display:none; background:linear-gradient(135deg, #5a9a6a, #4a7c59); border-color:#3a6c49; color:#fff;">리매치 요청</button>
      <a href="{% url 'games:lobby' %}" class="pill" id="lobby-btn" style="display:none; background:linear-gradient(135deg, #b08f66, #8a7050); border-color:#7a6040; color:#fff;">로비로 가기</a>
      <button class="pill" id="bgm-mute-btn" style="background:linear-gradient(135deg, #6b7280, #555); border-color:#444; color:#fff; font-size:13px;">BGM</button>
      <button class="pill theme-toggle" id="theme-toggle">다크모드</button>
    </div>
  </div>

  <!-- 타이머 (상단 중앙) -->
  <div class="timer-container" id="timerContainer" style="display:none;">
    <div class="timer-item">
      <div class="timer-label">흑(●)</div>
      <div class="timer-value black" id="blackTimer">15:00</div>
    </div>
    <div class="timer-item">
      <div class="timer-label">백(○)</div>
      <div class="timer-value white" id="whiteTimer">15:00</div>
    </div>
  </div>

  <div class="board-wrap" id="boardWrap">
    <svg id="grid" class="grid" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true"></svg>
    <div class="layer" id="stones"></div>
    <div class="layer" id="points"></div>
    <!-- 착수 확인 버튼 -->
    <button class="confirm-move-btn" id="confirm-move-btn">착수</button>
  </div>

  <!-- 빠른 채팅 -->
  <div class="quick-chat-container" id="quickChatContainer">
    <div class="quick-chat-panel">
      <button class="quick-chat-btn" data-message="안녕하세요!">안녕하세요!</button>
      <button class="quick-chat-btn" data-message="잘 부탁드립니다!">잘 부탁드립니다!</button>
      <button class="quick-chat-btn" data-message="수고하셨습니다!">수고하셨습니다!</button>
      <button class="quick-chat-btn" data-message="멋진데요?!">멋진데요?!</button>
      <button class="quick-chat-btn" data-message="잘하시네요!">잘하시네요!</button>
      <button class="quick-chat-btn" data-message="대단하네요!">대단하네요!</button>
      <button class="quick-chat-btn" data-message="빨리 두세요!">빨리 두세요!</button>
      <button class="quick-chat-btn" data-message="빨리빨리!">빨리빨리!</button>
      <button class="quick-chat-btn" data-message="감사합니다!">감사합니다!</button>
      <button class="quick-chat-btn" data-message="죄송합니다...">죄송합니다...</button>
    </div>
  </div>

  <!-- 게임 종료 모달 -->
  <div id="gameOverModal" class="game-over-modal">
    <div class="modal-content">
      <h2>게임 종료!</h2>
      <div class="winner-stone" id="modalStone"></div>
      <div class="winner-name" id="modalWinnerName"></div>
      <p style="font-size:1.1rem; color:#666;">승리하셨습니다!</p>
      <div id="ratingChange"></div>
      <button class="modal-btn" onclick="closeModal()">확인</button>
    </div>
  </div>

  <!-- 리매치 요청 모달 -->
  <div id="rematchRequestModal" class="game-over-modal">
    <div class="modal-content">
      <h2 style="color:#4a7c59;">리매치 요청</h2>
      <div class="rematch-icon"></div>
      <p style="font-size:1.3rem; font-weight:700; margin:1rem 0;">리매치 요청이 왔습니다!</p>
      <p style="font-size:1.1rem; color:#666;">재경기를 하시겠습니까?</p>
      <div style="display:flex; gap:12px; margin-top:1.5rem;">
        <button class="modal-btn" onclick="acceptRematch()" style="background:#4a7c59; flex:1;">승인</button>
        <button class="modal-btn" onclick="declineRematch()" style="background:#999; flex:1;">거절</button>
      </div>
    </div>
  </div>

  <!-- 재경기 카운트다운 모달 -->
  <div id="countdownModal" class="game-over-modal">
    <div class="modal-content">
      <h2 style="color:#4a7c59;">재경기 시작</h2>
      <div style="font-size:2rem; margin:1rem 0;">재경기를 시작합니다!</div>
      <div style="font-size:4rem; font-weight:900; color:#d84315; margin:1rem 0;" id="countdownNumber">3</div>
    </div>
  </div>

  <!-- 리매치 대기 모달 -->
  <div id="rematchWaitingModal" class="game-over-modal">
    <div class="modal-content">
      <h2 style="color:#4a7c59;">리매치 요청</h2>
      <div class="loading-spinner"></div>
      <p style="font-size:1.3rem; font-weight:700; margin:1rem 0;">
        리매치 요청을 기다리는중<span class="dots"></span>
      </p>
      <button class="modal-btn" onclick="cancelRematchRequest()" style="background:#999; margin-top:1rem;">취소</button>
    </div>
  </div>

  <!-- 플레이어 입장 모달 -->
  <div id="playerJoinedModal" class="game-over-modal">
    <div class="modal-content">
      <h2 style="color:#4a7c59;">플레이어 입장!</h2>
      <div style="font-size:2.5rem; margin:1rem 0;">●○</div>
      <p style="font-size:1.3rem; font-weight:700; margin:1rem 0;" id="joinedPlayerName"></p>
      <p style="font-size:1.1rem; color:#666;">게임이 시작됩니다!</p>
      <button class="modal-btn" onclick="closePlayerJoinedModal()" style="background:#4a7c59;">확인</button>
    </div>
  </div>

  <!-- 준비 모달 -->
  <div id="readyModal" class="game-over-modal">
    <div class="modal-content">
      <h2 style="color:#4a7c59;">게임 준비</h2>
      <div style="font-size:2rem; margin:1rem 0;">●○</div>

      <!-- 준비 상태 표시 -->
      <div style="margin:1.5rem 0; font-size:1.1rem;">
        <div style="margin:0.5rem 0;">
          <span style="font-weight:700;">흑(●):</span>
          <span id="readyBlackStatus" style="margin-left:0.5rem; color:#999;">준비 대기중...</span>
        </div>
        <div style="margin:0.5rem 0;">
          <span style="font-weight:700;">백(○):</span>
          <span id="readyWhiteStatus" style="margin-left:0.5rem; color:#999;">준비 대기중...</span>
        </div>
      </div>

      <!-- 준비 완료 버튼 -->
      <button id="readyBtn" class="modal-btn" style="background:#4a7c59; margin-top:1rem;" onclick="clickReady()">준비 완료</button>

      <!-- 게임 시작 버튼 (방장만, 양쪽 모두 준비 완료 시 표시) -->
      <button id="startGameBtn" class="modal-btn" style="background:#d84315; margin-top:0.5rem; display:none;" onclick="clickStartGame()">게임 시작</button>
    </div>
  </div>

  <!-- 배치 완료 모달 -->
  <div id="placementCompleteModal" class="game-over-modal">
    <div class="modal-content">
      <div class="placement-icon">
        <div class="shield"></div>
        <div class="sparkle"></div>
        <div class="sparkle"></div>
        <div class="sparkle"></div>
        <div class="sparkle"></div>
      </div>
      <h2 style="color:#ff8f00; margin-top:0.5rem;">배치 완료!</h2>
      <p style="font-size:1.1rem; color:#666; margin:0.5rem 0;">5판의 배치전이 끝났습니다</p>
      <div id="placementResultTier" style="margin:1.5rem 0;"></div>
      <p style="font-size:1rem; color:#888;">위 티어에서 시작합니다</p>
      <button class="modal-btn" onclick="closePlacementModal()" style="background:linear-gradient(135deg, #ff8f00, #ff6f00); margin-top:1.5rem;">확인</button>
    </div>
  </div>

  <!-- 티어 변동 모달 -->
  <div id="tierChangeModal" class="game-over-modal">
    <div class="modal-content">
      <div id="tierChangeIcon"></div>
      <h2 id="tierChangeTitle" style="margin-top:0.5rem;">티어 변동!</h2>
      <div style="display:flex; align-items:center; justify-content:center; gap:0.8rem; margin:1.5rem 0;">
        <div id="tierChangeOld"></div>
        <div id="tierChangeArrow" class="tier-arrow"></div>
        <div id="tierChangeNew"></div>
      </div>
      <p id="tierChangeMessage" style="font-size:1.1rem; color:#666;"></p>
      <button id="tierChangeBtn" class="modal-btn" onclick="closeTierChangeModal()" style="margin-top:1.5rem;">확인</button>
    </div>
  </div>

<script>
(function(){
  const SIZE   = {{ BOARD_SIZE }};
  const gameId = {{ game.id }};
  const scheme = (location.protocol === "https:") ? "wss" : "ws";
  const wsURL  = `${scheme}://${location.host}/ws/games/${gameId}/`;
  const currentUsername = "{{ user.username }}";  // 현재 로그인한 사용자 이름

  const gridEl       = document.getElementById("grid");
  const stonesEl     = document.getElementById("stones");
  const pointsEl     = document.getElementById("points");
  const wsState      = document.getElementById("ws-state");
  const turnEl       = document.getElementById("turn");
  const winnerTop    = document.getElementById("winnerTop");  // 상단 배지
  const blackPlayer  = document.getElementById("black-player");
  const whitePlayer  = document.getElementById("white-player");
  const blackTier    = document.getElementById("black-tier");
  const whiteTier    = document.getElementById("white-tier");
  const lobbyBtn     = document.getElementById("lobby-btn");
  const leaveBtn     = document.getElementById("leave-btn");
  const surrenderBtn = document.getElementById("surrender-btn");
  const rematchBtn   = document.getElementById("rematch-btn");
  const gameOverModal = document.getElementById("gameOverModal");
  const modalStone    = document.getElementById("modalStone");
  const modalWinnerName = document.getElementById("modalWinnerName");
  const playerJoinedModal = document.getElementById("playerJoinedModal");
  const joinedPlayerName = document.getElementById("joinedPlayerName");
  const timerContainer = document.getElementById("timerContainer");
  const blackTimer    = document.getElementById("blackTimer");
  const whiteTimer    = document.getElementById("whiteTimer");
  const readyModal = document.getElementById("readyModal");
  const readyBlackStatus = document.getElementById("readyBlackStatus");
  const readyWhiteStatus = document.getElementById("readyWhiteStatus");
  const readyBtn = document.getElementById("readyBtn");
  const startGameBtn = document.getElementById("startGameBtn");

  /* ===== 빠른 채팅 관련 변수 ===== */
  const quickChatContainer = document.getElementById("quickChatContainer");
  const quickChatToggleBtn = document.getElementById("quick-chat-toggle-btn");
  const quickChatBtns = document.querySelectorAll(".quick-chat-btn");

  /* ===== 타이머 관련 변수 ===== */
  let currentTurn = null;
  let currentBlackTime = 900;
  let currentWhiteTime = 900;
  let timerInterval = null;

  /* ===== 착수 중복 방지 ===== */
  let isPlaying = false;

  /* ===== 자신의 색상 정보 ===== */
  let myColor = null;  // "black" or "white"

  /* ===== 티어 시스템 ===== */
  const TIERS = [
    { name: "5급", minRp: 0, maxRp: 899, color: "#6b7280" },
    { name: "4급", minRp: 900, maxRp: 999, color: "#3b82f6" },
    { name: "3급", minRp: 1000, maxRp: 1099, color: "#06b6d4" },
    { name: "2급", minRp: 1100, maxRp: 1199, color: "#10b981" },
    { name: "1급", minRp: 1200, maxRp: 1299, color: "#22c55e" },
    { name: "1단", minRp: 1300, maxRp: 1399, color: "#84cc16" },
    { name: "2단", minRp: 1400, maxRp: 1499, color: "#eab308" },
    { name: "3단", minRp: 1500, maxRp: 1599, color: "#f59e0b" },
    { name: "낭인", minRp: 1600, maxRp: 1699, color: "#8b5cf6" },
    { name: "달인", minRp: 1700, maxRp: 1799, color: "#a855f7" },
    { name: "명인", minRp: 1800, maxRp: 1899, color: "#ec4899" },
    { name: "지존", minRp: 1900, maxRp: 1999, color: "#f43f5e" },
    { name: "패왕", minRp: 2000, maxRp: 2099, color: "#ef4444" },
    { name: "투신", minRp: 2100, maxRp: 2199, color: "#dc2626" },
    { name: "무신", minRp: 2200, maxRp: Infinity, color: "#b91c1c" },
  ];

  function getTier(rp) {
    for (const tier of TIERS) {
      if (rp >= tier.minRp && rp <= tier.maxRp) {
        return tier;
      }
    }
    return TIERS[0];
  }

  function getTierBadgeHTML(rp, totalGames = 999) {
    // 5판 미만이면 "배치중" 표시
    if (totalGames < 5) {
      return `<span class="tier-badge tier-placement">배치중</span>`;
    }
    const tier = getTier(rp);
    return `<span class="tier-badge tier-${tier.name}">${tier.name}</span>`;
  }

  // 큰 티어 뱃지 (모달용)
  function getLargeTierBadgeHTML(rp, totalGames = 999) {
    if (totalGames < 5) {
      return `<span class="tier-badge tier-placement" style="font-size: 2rem; padding: 0.8rem 1.5rem;">배치중</span>`;
    }
    const tier = getTier(rp);
    return `<span class="tier-badge tier-${tier.name}" style="font-size: 2rem; padding: 0.8rem 1.5rem;">${tier.name}</span>`;
  }

  // 타이머 포맷: 초 → MM:SS
  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  // 타이머 업데이트 함수
  function updateTimers() {
    if (!currentTurn) {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      return;
    }

    // 현재 턴 플레이어의 시간 1초 감소
    if (currentTurn === "black") {
      currentBlackTime = Math.max(0, currentBlackTime - 1);
      blackTimer.textContent = formatTime(currentBlackTime);
      updateTimerWarning(blackTimer, currentBlackTime);

      // 타임아웃 체크: 흑 시간이 0이 되면 서버에 알림
      if (currentBlackTime === 0) {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({type: "timeout", player: "black"}));
        }
        return;
      }
    } else {
      currentWhiteTime = Math.max(0, currentWhiteTime - 1);
      whiteTimer.textContent = formatTime(currentWhiteTime);
      updateTimerWarning(whiteTimer, currentWhiteTime);

      // 타임아웃 체크: 백 시간이 0이 되면 서버에 알림
      if (currentWhiteTime === 0) {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({type: "timeout", player: "white"}));
        }
        return;
      }
    }
  }

  // 타이머 인터벌 시작
  function startTimerInterval() {
    if (timerInterval) {
      clearInterval(timerInterval);
    }
    timerInterval = setInterval(updateTimers, 1000);
  }

  /* ===== 게임 종료 모달 ===== */
  let modalShown = false;  // 모달이 이미 표시되었는지 추적
  let isPracticeMode = false;  // 연습 모드 여부

  const rematchRequestModal = document.getElementById("rematchRequestModal");
  const rematchWaitingModal = document.getElementById("rematchWaitingModal");
  const countdownModal = document.getElementById("countdownModal");
  const countdownNumber = document.getElementById("countdownNumber");

  window.closeModal = function() {
    gameOverModal.style.display = "none";
    modalShown = false;

    // 연습 모드이면 게임판 리셋
    if (isPracticeMode && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type: "reset_practice"}));
    }
    // 대전 모드이면 그냥 모달만 닫고 게임룸에 남음 (리매치 버튼 활성화됨)

    // 대기 중인 모달(배치 완료/티어 변동) 표시
    showNextPendingModal();
  };

  // 리매치 요청 승인 함수
  window.acceptRematch = function() {
    if (ws.readyState !== WebSocket.OPEN) {
      alert("게임과 연결되지 않았습니다.");
      return;
    }

    // 서버에 리매치 수락 전송
    ws.send(JSON.stringify({type: "accept_rematch"}));

    // 요청 모달 닫기
    rematchRequestModal.style.display = "none";
  };

  // 리매치 요청 거절 함수
  window.declineRematch = function() {
    if (ws.readyState !== WebSocket.OPEN) {
      alert("게임과 연결되지 않았습니다.");
      return;
    }

    // 서버에 리매치 거절 전송
    ws.send(JSON.stringify({type: "decline_rematch"}));

    // 요청 모달 닫기
    rematchRequestModal.style.display = "none";

    // 사용자에게 알림
    alert("리매치를 거절했습니다.");
  };

  // 리매치 요청 취소 함수
  window.cancelRematchRequest = function() {
    if (ws.readyState !== WebSocket.OPEN) {
      alert("게임과 연결되지 않았습니다.");
      return;
    }

    // 서버에 리매치 취소 전송 (decline과 동일하게 처리)
    ws.send(JSON.stringify({type: "decline_rematch"}));

    // 대기 모달 닫기
    rematchWaitingModal.style.display = "none";

    // 리매치 버튼 리셋
    rematchBtn.textContent = "리매치 요청";
    rematchBtn.disabled = false;
    rematchBtn.style.opacity = "1";
    rematchBtn.style.cursor = "pointer";
  };

  // 카운트다운 시작 함수
  function startCountdown() {
    let count = 3;
    countdownNumber.textContent = count;
    countdownModal.style.display = "flex";

    const countInterval = setInterval(() => {
      count--;
      if (count > 0) {
        countdownNumber.textContent = count;
      } else {
        clearInterval(countInterval);
        countdownModal.style.display = "none";
        // 카운트다운 완료 후 준비 모달 표시
        showReadyModal();
      }
    }, 1000);
  }

  /* ===== 플레이어 입장 모달 ===== */
  window.closePlayerJoinedModal = function() {
    playerJoinedModal.style.display = "none";
    ensureAudioReady();
    // 플레이어 입장 모달 닫은 후 준비 모달 표시
    showReadyModal();
  };

  /* ===== 준비 모달 ===== */
  function showReadyModal() {
    // 이미 표시되어 있으면 중복 방지
    if (readyModal.style.display === "flex") return;

    // 다른 모든 모달 먼저 닫기
    playerJoinedModal.style.display = "none";
    gameOverModal.style.display = "none";
    rematchRequestModal.style.display = "none";
    rematchWaitingModal.style.display = "none";
    countdownModal.style.display = "none";

    readyModalShown = true;  // 플래그 설정
    readyModal.style.display = "flex";
    // 초기 상태: 모두 준비 대기중
    readyBlackStatus.textContent = "준비 대기중...";
    readyBlackStatus.style.color = "#999";
    readyWhiteStatus.textContent = "준비 대기중...";
    readyWhiteStatus.style.color = "#999";
    // 준비 버튼 표시, 게임 시작 버튼 숨김
    readyBtn.style.display = "inline-block";
    startGameBtn.style.display = "none";
  }

  window.clickReady = function() {
    if (ws.readyState !== WebSocket.OPEN) {
      alert("게임과 연결되지 않았습니다.");
      return;
    }
    // 준비 완료 메시지 전송
    ws.send(JSON.stringify({type: "player_ready"}));
    // 자신의 준비 버튼 비활성화 (중복 클릭 방지)
    readyBtn.disabled = true;
    readyBtn.style.opacity = "0.5";
    readyBtn.style.cursor = "not-allowed";
  };

  window.clickStartGame = function() {
    if (ws.readyState !== WebSocket.OPEN) {
      alert("게임과 연결되지 않았습니다.");
      return;
    }
    // 게임 시작 메시지 전송
    ws.send(JSON.stringify({type: "start_game"}));
  };

  function handleReadyState(data) {
    // 준비 상태 업데이트
    updateReadyStatus(readyBlackStatus, data.black_ready);
    updateReadyStatus(readyWhiteStatus, data.white_ready);

    // 양쪽 모두 준비 완료 && 방장이면 게임 시작 버튼 표시
    if (data.black_ready && data.white_ready && data.is_room_creator) {
      startGameBtn.style.display = "inline-block";
    } else {
      // 조건이 맞지 않으면 버튼 숨김
      startGameBtn.style.display = "none";
    }
  }

  function handleGameStart() {
    // 준비 모달 닫기
    readyModal.style.display = "none";
    // 준비 버튼 리셋 (다음 게임을 위해)
    readyBtn.disabled = false;
    readyBtn.style.opacity = "1";
    readyBtn.style.cursor = "pointer";
  }

  function handleRematchState(data) {
    // 양쪽 모두 리매치 수락하면 게임 리셋
    if (data.game_reset) {
      // 게임판 리셋되었으니 모달 리셋하고 준비 모달 표시
      modalShown = false;
      readyModalShown = false;
      gameOverModal.style.display = "none";

      // 리매치 버튼 리셋
      rematchBtn.textContent = "리매치 요청";
      rematchBtn.disabled = false;
      rematchBtn.style.opacity = "1";
      rematchBtn.style.cursor = "pointer";
      rematchBtn.style.display = "none";

      // 준비 모달 표시
      showReadyModal();
    } else if (data.rematch_black || data.rematch_white) {
      // 한쪽만 요청한 상태
      if (rematchBtn.textContent !== "요청됨...") {
        // 상대방이 요청한 경우
        rematchBtn.textContent = "상대방이 요청함";
      }
    }
  }

  function showPlayerJoinedModal(playerName) {
    joinedPlayerName.textContent = playerName + " 님이 입장했습니다!";
    playerJoinedModal.style.display = "flex";
  }

  // 배치 완료/티어 변동 대기열 (게임 결과 모달 닫은 후 순차 표시)
  let pendingModals = [];

  function showGameOverModal(winner, winnerName, isSoloPlay) {
    if (modalShown) return;  // 이미 표시되었으면 중복 방지

    modalShown = true;
    pendingModals = [];  // 대기열 초기화

    // 게임 결과 알림음 재생
    const isWinner = myColor === winner;
    playGameOverSound(isWinner);

    modalStone.textContent = winner === "black" ? "●" : "○";
    modalWinnerName.textContent = winnerName || (winner === "black" ? "흑" : "백");

    // 레이팅 변동 표시 (대전 모드일 때만)
    const ratingDisplay = document.getElementById("ratingChange");
    if (ratingDisplay && lastRatingInfo && !isSoloPlay) {
      const blackChange = lastRatingInfo.black_rating_change;
      const whiteChange = lastRatingInfo.white_rating_change;
      const blackRating = lastRatingInfo.black_rating;
      const whiteRating = lastRatingInfo.white_rating;
      const blackTotalGames = lastRatingInfo.black_total_games || 999;
      const whiteTotalGames = lastRatingInfo.white_total_games || 999;

      ratingDisplay.innerHTML = `
        <div style="margin-top:1rem; padding:0.8rem; background:#f8f9fa; border-radius:8px; font-size:0.95rem;">
          <div style="font-weight:700; margin-bottom:0.5rem; color:#666;">레이팅 변동</div>
          <div style="display:flex; justify-content:center; gap:2rem;">
            <div>
              <span style="font-weight:600;">흑(●)</span>
              ${getTierBadgeHTML(blackRating, blackTotalGames)}
              <span style="color:${blackChange >= 0 ? '#4a7c59' : '#c53030'}; font-weight:700; margin-left:0.3rem;">
                ${blackChange >= 0 ? '+' : ''}${blackChange}
              </span>
              <span style="color:#888; margin-left:0.3rem;">(${blackRating})</span>
            </div>
            <div>
              <span style="font-weight:600;">백(○)</span>
              ${getTierBadgeHTML(whiteRating, whiteTotalGames)}
              <span style="color:${whiteChange >= 0 ? '#4a7c59' : '#c53030'}; font-weight:700; margin-left:0.3rem;">
                ${whiteChange >= 0 ? '+' : ''}${whiteChange}
              </span>
              <span style="color:#888; margin-left:0.3rem;">(${whiteRating})</span>
            </div>
          </div>
        </div>
      `;
      ratingDisplay.style.display = "block";

      // 배치 완료/티어 변동 체크 (내 색상 기준)
      if (myColor === "black") {
        if (lastRatingInfo.black_placement_complete) {
          pendingModals.push({ type: 'placement', rating: blackRating, totalGames: blackTotalGames });
        } else if (lastRatingInfo.black_tier_changed) {
          pendingModals.push({
            type: 'tierChange',
            oldTier: lastRatingInfo.black_old_tier,
            newTier: lastRatingInfo.black_new_tier,
            isPromotion: blackChange > 0
          });
        }
      } else if (myColor === "white") {
        if (lastRatingInfo.white_placement_complete) {
          pendingModals.push({ type: 'placement', rating: whiteRating, totalGames: whiteTotalGames });
        } else if (lastRatingInfo.white_tier_changed) {
          pendingModals.push({
            type: 'tierChange',
            oldTier: lastRatingInfo.white_old_tier,
            newTier: lastRatingInfo.white_new_tier,
            isPromotion: whiteChange > 0
          });
        }
      }
    } else if (ratingDisplay) {
      ratingDisplay.style.display = "none";
    }

    // 혼자 플레이면 3초 후 자동으로 게임판 리셋
    if (isSoloPlay) {
      // 모달은 표시하지 않고, 3초 후 자동 리셋
      setTimeout(() => {
        resetGameForPractice();
      }, 3000);
    } else {
      // 상대방과 플레이: 모달 표시
      gameOverModal.style.display = "flex";
    }
  }

  // 배치 완료 모달 표시
  function showPlacementCompleteModal(rating, totalGames) {
    const resultTier = document.getElementById("placementResultTier");
    resultTier.innerHTML = getLargeTierBadgeHTML(rating, totalGames);
    document.getElementById("placementCompleteModal").style.display = "flex";
  }

  // 티어 변동 모달 표시
  function showTierChangeModal(oldTier, newTier, isPromotion) {
    const iconEl = document.getElementById("tierChangeIcon");
    const title = document.getElementById("tierChangeTitle");
    const message = document.getElementById("tierChangeMessage");
    const oldTierEl = document.getElementById("tierChangeOld");
    const newTierEl = document.getElementById("tierChangeNew");
    const arrowEl = document.getElementById("tierChangeArrow");
    const btn = document.getElementById("tierChangeBtn");

    // 이전 티어 (큰 뱃지)
    oldTierEl.innerHTML = `<span class="tier-badge tier-${oldTier}" style="font-size: 1.3rem; padding: 0.5rem 1rem;">${oldTier}</span>`;

    // 새 티어 (큰 뱃지)
    newTierEl.innerHTML = `<span class="tier-badge tier-${newTier}" style="font-size: 1.3rem; padding: 0.5rem 1rem;">${newTier}</span>`;

    if (isPromotion) {
      // 승급 아이콘
      iconEl.innerHTML = `
        <div class="promotion-icon">
          <div class="glow-ring"></div>
          <div class="glow-ring"></div>
          <div class="arrow-up"></div>
        </div>`;
      // 승급 화살표
      arrowEl.className = "tier-arrow promotion";
      arrowEl.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"/></svg>`;
      title.textContent = "티어 승급!";
      title.style.color = "#4caf50";
      message.textContent = "축하합니다! 티어가 올랐습니다!";
      btn.style.background = "linear-gradient(135deg, #4caf50, #388e3c)";
    } else {
      // 강등 아이콘
      iconEl.innerHTML = `
        <div class="demotion-icon">
          <div class="crack"></div>
          <div class="arrow-down"></div>
        </div>`;
      // 강등 화살표
      arrowEl.className = "tier-arrow demotion";
      arrowEl.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"/></svg>`;
      title.textContent = "티어 강등";
      title.style.color = "#e53935";
      message.textContent = "티어가 내려갔습니다. 다시 도전하세요!";
      btn.style.background = "linear-gradient(135deg, #e53935, #c62828)";
    }

    document.getElementById("tierChangeModal").style.display = "flex";
  }

  // 배치 완료 모달 닫기
  window.closePlacementModal = function() {
    document.getElementById("placementCompleteModal").style.display = "none";
    showNextPendingModal();
  };

  // 티어 변동 모달 닫기
  window.closeTierChangeModal = function() {
    document.getElementById("tierChangeModal").style.display = "none";
    showNextPendingModal();
  };

  // 대기 중인 다음 모달 표시
  function showNextPendingModal() {
    if (pendingModals.length === 0) return;

    const next = pendingModals.shift();
    if (next.type === 'placement') {
      showPlacementCompleteModal(next.rating, next.totalGames);
    } else if (next.type === 'tierChange') {
      showTierChangeModal(next.oldTier, next.newTier, next.isPromotion);
    }
  }

  // 연습용 게임판 리셋 함수
  function resetGameForPractice() {
    // 게임 상태 초기화
    modalShown = false;
    prevStoneCount = 0;

    // 서버에 리셋 요청 전송
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({type: "reset_practice"}));
    }

    // 빈 게임판으로 렌더링 (서버에서 broadcast_state로 다시 받겠지만, 즉각적인 UI 반응을 위해)
    const emptyBoard = ".".repeat(SIZE * SIZE);
    render({
      board: emptyBoard,
      turn: "black",
      winner: null,
      black_player: blackPlayer.textContent,
      white_player: null
    });
  }

  /* ===== 효과음 ===== */
  let prevStoneCount = 0;  // 이전 돌 개수 추적
  let audioCtx = null;  // AudioContext를 재사용

  /* ===== 헬퍼 함수들 ===== */
  // AudioContext resume 헬퍼
  function ensureAudioReady() {
    if (audioCtx && audioCtx.state === 'suspended') {
      return audioCtx.resume();
    }
    return Promise.resolve();
  }

  // 타이머 경고 표시 헬퍼
  function updateTimerWarning(timerEl, timeInSeconds) {
    if (timeInSeconds <= 30) {
      timerEl.classList.add("warning");
    } else {
      timerEl.classList.remove("warning");
    }
  }

  // 준비 상태 업데이트 헬퍼
  function updateReadyStatus(statusEl, isReady) {
    if (isReady) {
      statusEl.textContent = "준비 완료!";
      statusEl.style.color = "#4a7c59";
      statusEl.style.fontWeight = "700";
    } else {
      statusEl.textContent = "준비 대기중...";
      statusEl.style.color = "#999";
      statusEl.style.fontWeight = "";
    }
  }

  function initAudio() {
    if (!audioCtx) {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch(e) {
        console.error('AudioContext 생성 실패:', e);
      }
    }
    ensureAudioReady();
  }

  // 실제 재생 함수 먼저 선언 (호이스팅 이슈 방지)
  function actuallyPlaySound() {
    try {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended' || audioCtx.state === 'closed') return;

      // 매번 새로운 버퍼 생성
      const bufferSize = audioCtx.sampleRate * 0.05; // 50ms
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);

      // 화이트 노이즈 생성
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
      }

      // 버퍼 소스 생성
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;

      // 필터로 높은 주파수 강조 (날카로운 "딱" 소리)
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 1000;

      const gainNode = audioCtx.createGain();
      gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);

      noise.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      noise.start(audioCtx.currentTime);
      noise.stop(audioCtx.currentTime + 0.05);
    } catch(e) {
      console.error('효과음 재생 실패:', e);
    }
  }

  function playStoneSound(){
    try {
      // AudioContext가 없으면 초기화
      if (!audioCtx) {
        initAudio();
      }

      if (!audioCtx) return;

      // suspended 상태면 resume 후 재생
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          actuallyPlaySound();
        });
        return;
      }

      // running 상태면 바로 재생
      actuallyPlaySound();
    } catch(e) {
      console.error('효과음 재생 실패:', e);
    }
  }

  // 플레이어 입장 벨 소리 ("띠링~")
  function playJoinBellSound() {
    try {
      if (!audioCtx) {
        initAudio();
      }

      if (!audioCtx) return;

      // suspended 상태면 resume 후 재생
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          actuallyPlayBell();
        });
        return;
      }

      actuallyPlayBell();
    } catch(e) {
      console.error('벨 소리 재생 실패:', e);
    }
  }

  function actuallyPlayBell() {
    try {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended' || audioCtx.state === 'closed') return;

      const now = audioCtx.currentTime;

      // 첫 번째 음 (높은 "띠")
      const osc1 = audioCtx.createOscillator();
      osc1.type = 'sine';
      osc1.frequency.setValueAtTime(800, now);  // 높은 음

      const gain1 = audioCtx.createGain();
      gain1.gain.setValueAtTime(0.3, now);
      gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

      osc1.connect(gain1);
      gain1.connect(audioCtx.destination);

      osc1.start(now);
      osc1.stop(now + 0.3);

      // 두 번째 음 (낮은 "링~")
      const osc2 = audioCtx.createOscillator();
      osc2.type = 'sine';
      osc2.frequency.setValueAtTime(600, now + 0.15);  // 낮은 음

      const gain2 = audioCtx.createGain();
      gain2.gain.setValueAtTime(0.3, now + 0.15);
      gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

      osc2.connect(gain2);
      gain2.connect(audioCtx.destination);

      osc2.start(now + 0.15);
      osc2.stop(now + 0.5);
    } catch(e) {
      console.error('벨 소리 생성 실패:', e);
    }
  }

  // 게임 결과 알림음
  function playGameOverSound(isWinner) {
    try {
      if (!audioCtx) {
        initAudio();
      }

      if (!audioCtx) return;

      // suspended 상태면 resume 후 재생
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().then(() => {
          actuallyPlayGameOver(isWinner);
        });
        return;
      }

      actuallyPlayGameOver(isWinner);
    } catch(e) {
      console.error('게임 결과 알림음 재생 실패:', e);
    }
  }

  function actuallyPlayGameOver(isWinner) {
    try {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended' || audioCtx.state === 'closed') return;

      const now = audioCtx.currentTime;

      if (isWinner) {
        // 승리 사운드: 밝고 상승하는 3음 화음 (도-미-솔-도)
        const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
        notes.forEach((freq, i) => {
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + i * 0.12);

          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(0, now + i * 0.12);
          gain.gain.linearRampToValueAtTime(0.25, now + i * 0.12 + 0.05);
          gain.gain.linearRampToValueAtTime(0.15, now + i * 0.12 + 0.2);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.12 + 0.4);

          osc.connect(gain);
          gain.connect(audioCtx.destination);

          osc.start(now + i * 0.12);
          osc.stop(now + i * 0.12 + 0.4);
        });
      } else {
        // 패배 사운드: 하강하는 2음 (솔-미)
        const notes = [392, 330]; // G4, E4
        notes.forEach((freq, i) => {
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now + i * 0.2);

          const gain = audioCtx.createGain();
          gain.gain.setValueAtTime(0, now + i * 0.2);
          gain.gain.linearRampToValueAtTime(0.2, now + i * 0.2 + 0.05);
          gain.gain.linearRampToValueAtTime(0, now + i * 0.2 + 0.4);

          osc.connect(gain);
          gain.connect(audioCtx.destination);

          osc.start(now + i * 0.2);
          osc.stop(now + i * 0.2 + 0.4);
        });
      }
    } catch(e) {
      console.error('게임 결과 알림음 생성 실패:', e);
    }
  }

  // 사용자가 페이지와 상호작용하면 AudioContext 초기화 (브라우저 정책 대응)
  document.addEventListener('click', initAudio, { once: true });

  // 클릭할 때마다 AudioContext resume 시도 (suspend 방지)
  document.addEventListener('click', () => {
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  });

  /* ===== 좌표/격자 ===== */
  const MARGIN_PCT = 8;
  const innerMin   = MARGIN_PCT;
  const innerMax   = 100 - MARGIN_PCT;
  const step       = (innerMax - innerMin) / (SIZE - 1);

  function starPoints(size){
    if (size === 15) return [[4,4],[4,12],[8,8],[12,4],[12,12]];
    if (size === 19) return [[4,4],[4,10],[4,16],[10,4],[10,10],[10,16],[16,4],[16,10],[16,16]];
    if (size === 13) return [[4,4],[4,10],[7,7],[10,4],[10,10]];
    if (size % 2 === 1) { const mid = (size + 1) / 2; return [[mid, mid]]; }
    return [];
  }

  function drawGrid(){
    let g = "";
    g += `<rect x="0" y="0" width="100" height="100" fill="var(--wood)"/>`;
    g += `<rect x="1.2" y="1.2" width="97.6" height="97.6" fill="none"
               stroke="var(--border)" stroke-width="2.4" rx="2" ry="2"/>`;
    for (let i=0;i<SIZE;i++){
      const p = innerMin + i*step;
      g += `<line x1="${innerMin}" y1="${p}" x2="${innerMax}" y2="${p}"
                  stroke="var(--line)" stroke-width="0.6" />`;
      g += `<line x1="${p}" y1="${innerMin}" x2="${p}" y2="${innerMax}"
                  stroke="var(--line)" stroke-width="0.6" />`;
    }
    for (const [gx,gy] of starPoints(SIZE)){
      const cx = innerMin + (gx-1)*step;
      const cy = innerMin + (gy-1)*step;
      g += `<circle cx="${cx}" cy="${cy}" r="1.3" fill="#6e5239" opacity="0.9"/>`;
    }
    gridEl.innerHTML = g;
  }
  drawGrid();

  /* ===== 미리보기 ===== */
  let previewStone = null;  // 현재 미리보기 돌
  let currentBoardState = "";  // 현재 보드 상태 (미리보기 판단용)
  let currentTurnState = "black";  // 현재 턴 상태 (미리보기 색상용)
  let touchCoords = null;  // 모바일 터치 좌표 저장
  let aimedCoords = null;  // 착수 확인용 조준 좌표
  const confirmBtn = document.getElementById("confirm-move-btn");

  function showPreview(x, y, turn, aimed) {
    // 이미 미리보기가 있으면 제거
    hidePreview();

    // 빈 칸이 아니면 미리보기 표시 안 함
    const idx = y * SIZE + x;
    if (currentBoardState[idx] !== ".") return;

    const px = innerMin + x * step;
    const py = innerMin + y * step;
    const preview = document.createElement("div");
    preview.className = "stone preview " + (turn === "black" ? "black" : "white");
    if (aimed) preview.classList.add("aimed");
    preview.style.left = px + "%";
    preview.style.top = py + "%";
    preview.id = "preview-stone";
    stonesEl.appendChild(preview);
    previewStone = preview;
  }

  function hidePreview() {
    if (previewStone) {
      previewStone.remove();
      previewStone = null;
    }
  }

  // 조준 해제 (착수 확인 버튼 숨김 + 미리보기 제거)
  function clearAim() {
    aimedCoords = null;
    hidePreview();
    confirmBtn.classList.remove("visible");
  }

  // 조준 설정 (미리보기 표시 + 착수 확인 버튼 표시)
  function setAim(x, y) {
    // 같은 위치를 다시 클릭하면 조준 해제
    if (aimedCoords && aimedCoords.x === x && aimedCoords.y === y) {
      clearAim();
      return;
    }
    aimedCoords = {x, y};
    showPreview(x, y, currentTurnState, true);
    confirmBtn.classList.add("visible");
  }

  /* ===== 클릭 포인트 ===== */
  const pts = [];
  for (let y=0;y<SIZE;y++){
    for (let x=0;x<SIZE;x++){
      const px = innerMin + x*step;
      const py = innerMin + y*step;
      const btn = document.createElement("button");
      btn.className = "pt";
      btn.style.left = px + "%";
      btn.style.top  = py + "%";
      btn.dataset.x = x;
      btn.dataset.y = y;
      btn.addEventListener("click", onPlay);

      // 미리보기 이벤트 (PC)
      btn.addEventListener("mouseenter", (e) => {
        const bx = +e.currentTarget.dataset.x;
        const by = +e.currentTarget.dataset.y;
        // 조준 중인 위치가 아닌 곳에 마우스 올리면 일반 미리보기
        if (!aimedCoords || aimedCoords.x !== bx || aimedCoords.y !== by) {
          showPreview(bx, by, currentTurnState);
        }
      });
      btn.addEventListener("mouseleave", () => {
        // 조준 중이면 조준 미리보기 복원, 아니면 숨김
        if (aimedCoords) {
          showPreview(aimedCoords.x, aimedCoords.y, currentTurnState, true);
        } else {
          hidePreview();
        }
      });

      // 미리보기 이벤트 (모바일) - 터치로 조준
      btn.addEventListener("touchstart", (e) => {
        // 실제 터치 좌표로 가장 가까운 교차점 계산
        const boardEl = document.getElementById("boardWrap");
        const rect = boardEl.getBoundingClientRect();
        const touchX = e.touches[0].clientX - rect.left;
        const touchY = e.touches[0].clientY - rect.top;
        const cellWidth = rect.width * step / 100;
        const cellHeight = rect.height * step / 100;
        const offsetX = rect.width * innerMin / 100;
        const offsetY = rect.height * innerMin / 100;
        const bx = Math.round((touchX - offsetX) / cellWidth);
        const by = Math.round((touchY - offsetY) / cellHeight);

        // 범위 체크
        if (bx >= 0 && bx < SIZE && by >= 0 && by < SIZE) {
          // 터치 좌표 저장 (touchend에서 사용)
          touchCoords = {x: bx, y: by};
        }
      });

      btn.addEventListener("touchend", (e) => {
        // 터치 좌표로 조준 설정 (바로 착수하지 않음)
        if (touchCoords && ws.readyState === WebSocket.OPEN && !isPlaying) {
          e.preventDefault(); // click 이벤트 방지
          setAim(touchCoords.x, touchCoords.y);
          touchCoords = null;
        } else {
          touchCoords = null;
        }
      });

      btn.addEventListener("touchcancel", () => {
        touchCoords = null;
      });

      pointsEl.appendChild(btn);
      pts.push(btn);
    }
  }

  /* ===== WebSocket ===== */
  const ws = new WebSocket(wsURL);
  ws.addEventListener("open",  ()=> wsState.textContent = "");
  ws.addEventListener("close", e => wsState.textContent = "연결 끊김");
  ws.addEventListener("error", ()=> wsState.textContent = "연결 오류");
  ws.addEventListener("message", (e)=>{
    const m = JSON.parse(e.data);
    if (m.type === "state") {
      render(m);
    } else if (m.type === "player_joined") {
      // 플레이어 입장 모달 표시
      const playerName = m.white_player || "상대방";
      showPlayerJoinedModal(playerName);
      // 입장 벨 소리 재생 ("띠링~")
      playJoinBellSound();
      // 초기화된 상태로 렌더링
      render(m);
      // 돌 카운트도 리셋
      prevStoneCount = 0;
      // 입장 모달을 자동으로 3초 후 닫고 준비 모달 표시
      setTimeout(() => {
        if (playerJoinedModal.style.display === "flex") {
          closePlayerJoinedModal();
        }
      }, 3000);
    } else if (m.type === "ready_state") {
      // 준비 상태 업데이트
      handleReadyState(m);
    } else if (m.type === "game_start") {
      // 게임 시작
      handleGameStart();
      // 게임 상태 렌더링
      render(m);
    } else if (m.type === "error") {
      // 착수 에러 발생 시 플래그 해제 (다음 착수 가능하도록)
      isPlaying = false;
      clearAim();
      alert(m.message);
    } else if (m.type === "game_deleted") {
      // 게임이 삭제되었으므로 로비로 이동
      if (window.showToast) {
        showToast("방 생성자가 나가서 게임이 종료되었습니다.", "info");
        // 토스트를 보여주고 2초 후 리다이렉트
        setTimeout(() => {
          window.location.href = "{% url 'games:lobby' %}";
        }, 2000);
      } else {
        // 폴백: showToast가 없으면 바로 리다이렉트
        window.location.href = "{% url 'games:lobby' %}";
      }
    } else if (m.type === "rematch_state") {
      // 리매치 상태 업데이트
      handleRematchState(m);
    } else if (m.type === "rematch_request") {
      // 상대방으로부터 리매치 요청이 왔을 때 대기 모달 숨기고 요청 모달 표시
      rematchWaitingModal.style.display = "none";
      rematchRequestModal.style.display = "flex";
    } else if (m.type === "rematch_accepted") {
      // 양쪽 모두 리매치를 수락했을 때 대기 모달 숨기고 카운트다운 시작
      rematchWaitingModal.style.display = "none";
      startCountdown();
    } else if (m.type === "rematch_declined") {
      // 상대방이 리매치를 거절했을 때
      // 대기 모달이 표시되어 있었으면 요청자이므로 알림 표시
      if (rematchWaitingModal.style.display === "flex") {
        rematchWaitingModal.style.display = "none";
        alert("상대방이 리매치를 거절했습니다.");
      }
      // 리매치 버튼 리셋
      rematchBtn.textContent = "리매치 요청";
      rematchBtn.disabled = false;
      rematchBtn.style.opacity = "1";
      rematchBtn.style.cursor = "pointer";
    } else if (m.type === "opponent_left") {
      // 상대방이 게임 종료 후 나갔을 때
      // 대기 모달이 있으면 닫기
      if (rematchWaitingModal.style.display === "flex") {
        rematchWaitingModal.style.display = "none";
      }
      // 리매치 버튼 비활성화
      rematchBtn.textContent = "상대방이 나감";
      rematchBtn.disabled = true;
      rematchBtn.style.opacity = "0.5";
      rematchBtn.style.cursor = "not-allowed";
    } else if (m.type === "quick_chat") {
      // 상대방이 보낸 빠른 채팅 메시지 표시 (색상 정보 포함)
      showChatBubble(m.message, m.is_black);
    }
  });

  function onPlay(e){
    if (ws.readyState !== WebSocket.OPEN){
      alert("게임과 연결되지 않았습니다."); return;
    }
    // 착수 중이면 무시 (중복 클릭 방지)
    if (isPlaying) return;

    // 버튼의 dataset에서 직접 좌표 가져오기
    const x = +e.currentTarget.dataset.x;
    const y = +e.currentTarget.dataset.y;

    // 조준 모드: 클릭 시 조준점만 표시
    setAim(x, y);
  }

  // 착수 확인 버튼 클릭 → 실제 착수 전송
  confirmBtn.addEventListener("click", () => {
    if (!aimedCoords) return;
    if (ws.readyState !== WebSocket.OPEN) {
      alert("게임과 연결되지 않았습니다."); return;
    }
    if (isPlaying) return;

    const {x, y} = aimedCoords;

    // 착수 중 플래그 설정
    isPlaying = true;

    ws.send(JSON.stringify({type:"play", x, y}));

    // 조준 해제
    clearAim();

    // 안전장치: 3초 후에도 응답이 없으면 플래그 해제
    setTimeout(() => {
      if (isPlaying) {
        console.warn('착수 응답 타임아웃, 플래그 해제');
        isPlaying = false;
      }
    }, 3000);
  });

  /* ===== 항복 버튼 ===== */
  surrenderBtn.addEventListener("click", ()=>{
    if (ws.readyState !== WebSocket.OPEN){
      alert("게임과 연결되지 않았습니다."); return;
    }
    if (confirm("정말 항복하시겠습니까?")) {
      ws.send(JSON.stringify({type:"surrender"}));
    }
  });

  /* ===== 리매치 버튼 ===== */
  rematchBtn.addEventListener("click", ()=>{
    if (ws.readyState !== WebSocket.OPEN){
      alert("게임과 연결되지 않았습니다."); return;
    }
    ws.send(JSON.stringify({type:"request_rematch"}));
    // 버튼 텍스트 변경 및 비활성화
    rematchBtn.textContent = "요청됨...";
    rematchBtn.disabled = true;
    rematchBtn.style.opacity = "0.5";
    rematchBtn.style.cursor = "not-allowed";

    // 대기 모달 표시
    rematchWaitingModal.style.display = "flex";
  });

  /* ===== 빠른 채팅 ===== */
  // 빠른 채팅 토글 버튼 이벤트
  quickChatToggleBtn.addEventListener("click", () => {
    quickChatContainer.classList.toggle("active");
  });

  // 빠른 채팅 버튼 클릭 이벤트
  quickChatBtns.forEach(btn => {
    btn.addEventListener("click", () => {
      const message = btn.dataset.message;
      if (ws.readyState === WebSocket.OPEN) {
        // 자기 자신에게도 말풍선 표시 (자신의 색상으로)
        const isBlack = myColor === "black";
        showChatBubble(message, isBlack);
        // 서버로 전송
        ws.send(JSON.stringify({type: "quick_chat", message: message}));
      }
    });
  });

  // 말풍선 표시 함수
  function showChatBubble(message, isBlack) {
    // 기존 말풍선 제거
    const existingBubble = document.querySelector(".chat-bubble");
    if (existingBubble) {
      existingBubble.remove();
    }

    // 새 말풍선 생성
    const bubble = document.createElement("div");
    bubble.className = "chat-bubble";

    // 흑/백 색상 클래스 추가
    if (isBlack) {
      bubble.classList.add("black");
    } else {
      bubble.classList.add("white");
    }

    bubble.textContent = message;
    document.body.appendChild(bubble);

    // 2.5초 후 자동 제거
    setTimeout(() => {
      bubble.remove();
    }, 2500);
  }

  /* ===== 렌더 ===== */
  let readyModalShown = false;  // 준비 모달이 이미 표시되었는지 추적
  let prevBoard = "";  // 이전 보드 상태 (마지막 착수 찾기용)
  let lastStoneIndex = -1;  // 마지막 착수 위치 (전역으로 관리)

  // 레이팅 변동 정보 저장용
  let lastRatingInfo = null;

  function render(state){
    const {
      board, turn, winner, black_player, white_player, black_username, white_username,
      black_id, white_id,
      black_time, white_time, black_rating, white_rating, black_rating_change, white_rating_change,
      black_total_games, white_total_games,
      // 배치/티어 변동 정보
      black_old_tier, black_new_tier, black_tier_changed, black_placement_complete,
      white_old_tier, white_new_tier, white_tier_changed, white_placement_complete
    } = state;

    // 착수 완료, 플래그 해제
    isPlaying = false;

    // 새 상태 수신 시 조준 해제
    clearAim();

    // 연습 모드 감지 (양쪽 플레이어가 모두 없으면 연습 모드)
    isPracticeMode = !black_player || !white_player;

    // 신고 대상 업데이트
    if (window.updateReportTarget && black_player && white_player) {
      window.updateReportTarget(black_id, white_id, black_player, white_player, black_username, white_username);
    }

    // 레이팅 변동 정보 저장 (게임 종료 시)
    if (black_rating_change !== undefined || white_rating_change !== undefined) {
      lastRatingInfo = {
        black_rating, white_rating, black_rating_change, white_rating_change,
        black_total_games, white_total_games,
        // 배치/티어 변동 정보
        black_old_tier, black_new_tier, black_tier_changed, black_placement_complete,
        white_old_tier, white_new_tier, white_tier_changed, white_placement_complete
      };
    }

    // 플레이어 정보 업데이트 (티어 + 레이팅 포함)
    if (black_player) {
      const ratingText = black_rating ? ` (${black_rating})` : '';
      blackPlayer.textContent = black_player + ratingText;
      blackTier.innerHTML = black_rating ? getTierBadgeHTML(black_rating, black_total_games || 0) : '';
    } else {
      blackPlayer.textContent = "대기중...";
      blackTier.innerHTML = '';
    }
    if (white_player) {
      const ratingText = white_rating ? ` (${white_rating})` : '';
      whitePlayer.textContent = white_player + ratingText;
      whiteTier.innerHTML = white_rating ? getTierBadgeHTML(white_rating, white_total_games || 0) : '';
    } else {
      whitePlayer.textContent = "대기중...";
      whiteTier.innerHTML = '';
    }

    // 현재 사용자의 색상 결정 (빠른 채팅 말풍선 색상용)
    if (black_username === currentUsername) {
      myColor = "black";
    } else if (white_username === currentUsername) {
      myColor = "white";
    } else {
      myColor = null;  // 관전자 또는 미참여
    }

    // 돌 렌더
    stonesEl.innerHTML = "";
    let currentStoneCount = 0;

    // 마지막 착수 위치 찾기 (새로운 돌이 추가되었을 때만)
    if (prevBoard && prevBoard.length === board.length) {
      for (let i = 0; i < board.length; i++) {
        if (prevBoard[i] === "." && board[i] !== ".") {
          lastStoneIndex = i;  // 새로 추가된 돌의 위치 업데이트
        }
      }
    }

    for (let i=0;i<board.length;i++){
      const cell = board[i];
      if (cell === ".") continue;
      currentStoneCount++;
      const x = i % SIZE;
      const y = Math.floor(i / SIZE);
      const px = innerMin + x*step;
      const py = innerMin + y*step;
      const d = document.createElement("div");
      d.className = "stone " + (cell==="B" ? "black" : "white");

      // 마지막 착수된 돌이면 애니메이션 클래스 추가
      if (i === lastStoneIndex) {
        d.className += " new-move last-move";
      }

      d.style.left = px + "%";
      d.style.top  = py + "%";
      stonesEl.appendChild(d);
    }

    // 새로운 돌이 추가되었으면 효과음 재생
    if (currentStoneCount > prevStoneCount) {
      playStoneSound();
    }
    prevStoneCount = currentStoneCount;

    // 양쪽 플레이어가 모두 있고, 게임이 시작되지 않았고, 준비 모달을 아직 안 봤으면 표시
    if (black_player && white_player && currentStoneCount === 0 && !readyModalShown && !winner) {
      readyModalShown = true;
      showReadyModal();
    }

    // 상단 승자 배지 & 턴 & 나가기/항복 버튼 & 로비 버튼 & 새 게임 버튼 & 게임 종료 모달
    if (winner){
      const text = `승자: ${winner==="black" ? "흑(●)" : "백(○)"}`;
      winnerTop.textContent = text;
      winnerTop.style.display = "inline-block";
      turnEl.textContent = "";
      // 나가기/항복 버튼 숨김
      leaveBtn.style.display = "none";
      surrenderBtn.style.display = "none";
      // 리매치 버튼 표시 및 리셋 (대전 모드일 때만)
      if (!isPracticeMode) {
        rematchBtn.style.display = "inline-block";
        rematchBtn.textContent = "리매치 요청";
        rematchBtn.disabled = false;
        rematchBtn.style.opacity = "1";
        rematchBtn.style.cursor = "pointer";
      } else {
        rematchBtn.style.display = "none";
      }
      // 로비로 가기 버튼 표시
      lobbyBtn.style.display = "inline-block";

      // 🎉 게임 종료 모달 표시 (승자 닉네임과 함께)
      const winnerName = winner === "black" ? black_player : white_player;
      // 혼자 플레이인지 확인 (백 플레이어가 없으면 혼자)
      const isSoloPlay = !white_player || white_player === "대기중...";
      showGameOverModal(winner, winnerName, isSoloPlay);
    }else{
      winnerTop.style.display = "none";
      turnEl.textContent = `턴: ${turn==="black" ? "흑(●)" : "백(○)"}`;

      // 게임 진행 중: 양쪽 플레이어가 모두 있는지 확인
      if (black_player && white_player) {
        // 게임이 시작되었는지 확인 (돌이 하나라도 놓였는지)
        if (currentStoneCount > 0) {
          // 게임 시작됨: 항복 버튼만 표시
          leaveBtn.style.display = "none";
          surrenderBtn.style.display = "inline-block";
        } else {
          // 게임 시작 전: 나가기 버튼만 표시
          leaveBtn.style.display = "inline-block";
          surrenderBtn.style.display = "none";
        }
        // 대전 모드에서는 로비 버튼 숨김
        lobbyBtn.style.display = "none";
      } else {
        // 한쪽 플레이어만 있으면 (연습 모드) 나가기 버튼 표시 (방 삭제됨)
        leaveBtn.style.display = "inline-block";
        surrenderBtn.style.display = "none";
        lobbyBtn.style.display = "none";
      }

      // 게임 진행 중이면 리매치 버튼 숨김
      rematchBtn.style.display = "none";
    }

    // 빈 칸만 클릭 가능 (게임이 끝났으면 모두 비활성화)
    for (let i=0;i<pts.length;i++){
      pts[i].disabled = winner || (board[i] !== ".");
    }

    // ===== 타이머 업데이트 =====
    // 양쪽 플레이어가 모두 있고, 타이머 정보가 있으면 타이머 표시
    if (black_player && white_player && black_time !== undefined && white_time !== undefined) {
      // 타이머 정보 업데이트
      currentBlackTime = black_time || 0;
      currentWhiteTime = white_time || 0;
      currentTurn = turn;

      // 타이머 표시
      blackTimer.textContent = formatTime(currentBlackTime);
      whiteTimer.textContent = formatTime(currentWhiteTime);
      updateTimerWarning(blackTimer, currentBlackTime);
      updateTimerWarning(whiteTimer, currentWhiteTime);

      // 현재 턴 플레이어에게 active 클래스 추가
      if (turn === "black") {
        blackTimer.classList.add("active");
        whiteTimer.classList.remove("active");
      } else {
        whiteTimer.classList.add("active");
        blackTimer.classList.remove("active");
      }

      // 게임이 진행 중이고 승자가 없으면 타이머 표시 및 인터벌 시작
      if (!winner && currentStoneCount > 0) {
        timerContainer.style.display = "flex";
        startTimerInterval();
      } else {
        // 게임이 끝났으면 타이머 인터벌 중지
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        // 게임 종료 시 타이머 숨김
        if (winner) {
          timerContainer.style.display = "none";
          blackTimer.classList.remove("active");
          whiteTimer.classList.remove("active");
        }
      }
    } else {
      // 플레이어가 없으면 타이머 숨김
      timerContainer.style.display = "none";
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    // ===== 빠른 채팅 토글 버튼 표시/숨김 =====
    // 양쪽 플레이어가 모두 있고, 게임이 끝나지 않았으면 토글 버튼 표시
    if (black_player && white_player && !winner) {
      quickChatToggleBtn.style.display = "inline-block";
    } else {
      quickChatToggleBtn.style.display = "none";
      // 게임이 끝났거나 플레이어가 없으면 채팅 컨테이너도 숨김
      quickChatContainer.classList.remove("active");
    }

    // 현재 보드 상태를 저장 (다음 render 시 마지막 착수 찾기용)
    prevBoard = board;

    // 미리보기를 위한 상태 업데이트
    currentBoardState = board;
    currentTurnState = turn;
  }
})();
</script>

<!-- Toast Container -->
<div class="toast-container" id="toast-container"></div>

<!-- Toast Notification Script -->
<script>
(function(){
  {% if messages %}
    const toastContainer = document.getElementById('toast-container');
    const messages = [
      {% for message in messages %}
        {
          type: '{{ message.tags }}',
          text: '{{ message|escapejs }}'
        },
      {% endfor %}
    ];

    messages.forEach((msg, index) => {
      setTimeout(() => showToast(msg.text, msg.type), index * 300);
    });
  {% endif %}

  function showToast(message, type = 'info') {
    const toastContainer = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const icons = {
      success: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" fill="#4a7c59"/>
        <path d="M7 12l3 3 7-7" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`,
      error: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" fill="#c53030"/>
        <path d="M8 8l8 8M16 8l-8 8" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      </svg>`,
      info: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" fill="#4a7c89"/>
        <path d="M12 11v6M12 7v1" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      </svg>`
    };

    toast.innerHTML = `
      <span class="toast-icon">${icons[type] || icons.info}</span>
      <div class="toast-content">
        <div class="toast-message">${message}</div>
      </div>
      <button class="toast-close" onclick="this.parentElement.remove()">×</button>
    `;

    toastContainer.appendChild(toast);

    // Auto-dismiss after 5 seconds
    setTimeout(() => {
      toast.classList.add('slide-out');
      setTimeout(() => toast.remove(), 300);
    }, 5000);
  }

  // Make showToast globally available
  window.showToast = showToast;
})();
</script>

<script>
// 테마 토글
(function() {
  const themeToggle = document.getElementById('theme-toggle');
  const html = document.documentElement;

  function updateText(theme) {
    if (themeToggle) {
      themeToggle.textContent = theme === 'dark' ? '라이트모드' : '다크모드';
    }
  }

  updateText(html.getAttribute('data-theme') || 'light');

  if (themeToggle) {
    themeToggle.addEventListener('click', function() {
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      updateText(newTheme);
    });
  }
})();
</script>

<!-- Game BGM -->
<audio id="bgm-game" loop preload="auto">
  <source src="/static/audio/game.mp3" type="audio/mpeg">
</audio>

<script>
(function() {
  const bgmGame = document.getElementById('bgm-game');
  const muteBtn = document.getElementById('bgm-mute-btn');

  let bgmEnabled = localStorage.getItem('bgm-enabled') !== 'false';
  let bgmVolume = parseFloat(localStorage.getItem('bgm-volume') || '0.3');

  function updateMuteBtn() {
    if (muteBtn) {
      muteBtn.textContent = bgmEnabled ? 'BGM OFF' : 'BGM ON';
      muteBtn.style.opacity = bgmEnabled ? '0.5' : '1';
    }
  }

  function startBgm() {
    if (!bgmEnabled || !bgmGame) return;
    bgmGame.volume = bgmVolume;
    bgmGame.play().catch(() => {});
  }

  updateMuteBtn();

  if (sessionStorage.getItem('bgm-interacted')) {
    startBgm();
  } else {
    function onFirstInteraction() {
      sessionStorage.setItem('bgm-interacted', '1');
      startBgm();
      document.removeEventListener('click', onFirstInteraction);
      document.removeEventListener('touchstart', onFirstInteraction);
      document.removeEventListener('keydown', onFirstInteraction);
    }
    document.addEventListener('click', onFirstInteraction);
    document.addEventListener('touchstart', onFirstInteraction);
    document.addEventListener('keydown', onFirstInteraction);
  }

  if (muteBtn) {
    muteBtn.addEventListener('click', () => {
      bgmEnabled = !bgmEnabled;
      localStorage.setItem('bgm-enabled', bgmEnabled);
      updateMuteBtn();
      if (bgmEnabled) {
        bgmGame.volume = bgmVolume;
        bgmGame.play().catch(() => {});
      } else {
        bgmGame.pause();
      }
    });
  }
})();
</script>

<!-- 신고 모달 -->
<div class="report-modal" id="report-modal">
  <div class="report-content">
    <h3>상대방 신고</h3>
    <div class="report-target" id="report-target-info"></div>
    <label for="report-reason">신고 사유</label>
    <select id="report-reason">
      <option value="">선택하세요</option>
      <option value="abuse">욕설/비하</option>
      <option value="spam">도배/스팸</option>
      <option value="cheat">핵/치팅 의심</option>
      <option value="stalling">고의 시간끌기</option>
      <option value="inappropriate">부적절한 행동</option>
      <option value="other">기타</option>
    </select>
    <label for="report-description">상세 설명 (선택)</label>
    <textarea id="report-description" placeholder="추가 설명이 있다면 입력해주세요..."></textarea>
    <div class="report-actions">
      <button class="btn-report-cancel" id="report-cancel-btn">취소</button>
      <button class="btn-report-submit" id="report-submit-btn">신고</button>
    </div>
  </div>
</div>

<script>
// 신고 모달 로직
(function(){
  const reportModal = document.getElementById("report-modal");
  const reportReason = document.getElementById("report-reason");
  const reportDescription = document.getElementById("report-description");
  const reportTargetInfo = document.getElementById("report-target-info");
  const reportCancelBtn = document.getElementById("report-cancel-btn");
  const reportSubmitBtn = document.getElementById("report-submit-btn");
  const reportBtn = document.getElementById("report-btn");

  let opponentUserId = null;
  let opponentName = "";

  window.updateReportTarget = function(blackId, whiteId, blackPlayer, whitePlayer, blackUsername, whiteUsername) {
    const currentUser = "{{ user.username }}";
    if (blackUsername === currentUser) {
      opponentUserId = whiteId;
      opponentName = whitePlayer;
    } else if (whiteUsername === currentUser) {
      opponentUserId = blackId;
      opponentName = blackPlayer;
    }

    if (opponentUserId) {
      reportBtn.style.display = "inline-block";
    }
  };

  reportBtn.addEventListener("click", () => {
    if (!opponentUserId) return;
    reportTargetInfo.textContent = "대상: " + opponentName;
    reportReason.value = "";
    reportDescription.value = "";
    reportModal.classList.add("active");
  });

  reportCancelBtn.addEventListener("click", () => {
    reportModal.classList.remove("active");
  });

  reportModal.addEventListener("click", (e) => {
    if (e.target === reportModal) {
      reportModal.classList.remove("active");
    }
  });

  reportSubmitBtn.addEventListener("click", async () => {
    if (!reportReason.value) {
      if (window.showToast) window.showToast("신고 사유를 선택해주세요.", "error");
      return;
    }

    reportSubmitBtn.disabled = true;
    reportSubmitBtn.textContent = "접수 중...";

    try {
      const csrfToken = document.querySelector("[name=csrfmiddlewaretoken]");
      const token = csrfToken ? csrfToken.value : "{{ csrf_token }}";

      const response = await fetch("{% url 'games:submit_report' %}", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": token,
        },
        body: JSON.stringify({
          reported_user_id: opponentUserId,
          report_type: "game",
          reason: reportReason.value,
          description: reportDescription.value,
          evidence: "게임 ID: " + {{ game.id }},
        }),
      });

      const result = await response.json();

      if (response.ok) {
        if (window.showToast) window.showToast(result.message, "success");
      } else {
        if (window.showToast) window.showToast(result.error, "error");
      }
    } catch (err) {
      console.error("신고 오류:", err);
      if (window.showToast) window.showToast("신고 접수 중 오류가 발생했습니다.", "error");
    } finally {
      reportSubmitBtn.disabled = false;
      reportSubmitBtn.textContent = "신고";
      reportModal.classList.remove("active");
    }
  });
})();
</script>

</body>
</html>